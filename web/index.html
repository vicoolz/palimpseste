<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PALIMPSESTE</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <!-- Supabase SDK (async pour ne pas bloquer) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" async></script>
    <style>
        :root {
            --bg: #0d0d0d;
            --bg-card: #161618;
            --bg-elevated: #1e1e21;
            --text: #e8e6e3;
            --text-secondary: #9d9a95;
            --muted: #5c5a56;
            --accent: #e63946;
            --accent-secondary: #f4a261;
            --accent-tertiary: #2a9d8f;
            --accent-purple: #9b5de5;
            --border: #2a2a2d;
            --glow: 0 0 60px rgba(230,57,70,0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            /* Grain subtil façon vieux papier */
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
        }
        
        /* Stats Panel - Style épuré */
        .stats-panel {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 260px;
            background: linear-gradient(180deg, var(--bg-card) 0%, var(--bg) 100%);
            border-right: 1px solid var(--border);
            padding: 1.5rem 1.25rem;
            overflow-y: auto;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .stats-logo {
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.25em;
            color: var(--text);
            text-transform: uppercase;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .stats-section h3 {
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 0.75rem;
        }
        .big-number {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text), var(--text-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }
        .big-number-label {
            font-size: 0.75rem;
            color: var(--muted);
            margin-top: 0.25rem;
        }
        .mini-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }
        .mini-stat {
            background: var(--bg-elevated);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .mini-stat-value {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--text);
        }
        .mini-stat-label {
            font-size: 0.7rem;
            color: var(--muted);
            margin-top: 0.2rem;
        }
        
        /* Author bars */
        .author-bars {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .author-bar {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .author-bar-name {
            font-size: 0.75rem;
            color: var(--text-secondary);
            width: 100px;
            flex-shrink: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .author-bar-track {
            flex: 1;
            height: 6px;
            background: var(--bg);
            border-radius: 3px;
            overflow: hidden;
        }
        .author-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        .author-bar-count {
            font-size: 0.7rem;
            color: var(--muted);
            width: 24px;
            text-align: right;
        }
        
        /* Genre pills */
        .genre-chart {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .genre-pill {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-elevated);
            border-radius: 100px;
            border: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        .genre-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        /* Connexions */
        .connections-section { margin-top: 0.5rem; }
        .connections-hint {
            font-size: 0.7rem;
            color: var(--muted);
            margin-bottom: 0.75rem;
        }
        .connection-graph {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .connection-item {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .connection-item:hover {
            border-color: var(--accent);
            transform: translateX(3px);
        }
        .connection-node {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text);
        }
        .connection-node.discovered {
            color: var(--accent-tertiary);
        }
        .connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            flex-shrink: 0;
        }
        .connection-node.discovered .connection-dot {
            background: var(--accent-tertiary);
        }
        .connection-label {
            font-size: 0.6rem;
            color: var(--muted);
            margin-top: 0.3rem;
            margin-left: 1rem;
        }
        
        /* Fun stats */
        .fun-stat {
            margin-top: 1rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, rgba(255,159,10,0.1), rgba(191,90,242,0.1));
            border-radius: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.4;
        }
        .fun-stat strong { color: var(--accent-secondary); }
        
        /* Section Favoris */
        .favorites-section {
            max-height: 280px;
            overflow-y: auto;
        }
        .favorite-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem 0.6rem;
            background: transparent;
            border-left: 2px solid var(--accent);
            margin-bottom: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .favorite-item:hover {
            background: var(--bg-elevated);
            padding-left: 0.8rem;
        }
        .favorite-content {
            flex: 1;
            min-width: 0;
        }
        .favorite-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .favorite-author {
            font-size: 0.6rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .favorite-preview {
            display: none; /* Simplifié */
        }
        .favorite-remove {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            padding: 0.2rem;
            font-size: 0.7rem;
            opacity: 0;
            transition: all 0.2s;
        }
        .favorite-item:hover .favorite-remove {
            opacity: 1;
        }
        .favorite-remove:hover {
            color: var(--accent);
        }
        .favorites-empty {
            font-size: 0.75rem;
            color: var(--muted);
            text-align: center;
            padding: 1rem;
            font-style: italic;
        }
        .source-badge {
            font-size: 0.55rem;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            background: rgba(191,90,242,0.2);
            color: var(--accent-purple);
            margin-left: 0.3rem;
        }
        
        /* Achievements */
        .achievements {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .achievement {
            padding: 0.4rem 0.6rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            opacity: 0.4;
            transition: all 0.3s;
            cursor: help;
        }
        .achievement.unlocked {
            opacity: 1;
            border-color: var(--accent-secondary);
            background: rgba(255,159,10,0.1);
        }
        .achievement:hover {
            transform: scale(1.05);
        }
        .achievement-icon { font-size: 1rem; }
        
        /* Path visualization */
        .reading-path {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
            font-size: 0.65rem;
        }
        .path-node {
            padding: 0.2rem 0.4rem;
            background: var(--bg-elevated);
            border-radius: 4px;
            color: var(--text-secondary);
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .path-arrow { color: var(--muted); }
        
        /* Recommandation banner */
        .reco-banner {
            background: linear-gradient(135deg, rgba(255,69,58,0.15), rgba(191,90,242,0.15));
            border: 1px solid rgba(255,69,58,0.3);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
            display: none;
            /* Positionnement identique au main */
            margin-left: 260px;
            max-width: 720px;
            margin-right: auto;
            margin-left: calc(260px + (100% - 260px - 720px) / 2);
            padding-left: 2rem;
            padding-right: 2rem;
            position: relative;
            z-index: 10;
        }
        .reco-banner.show { display: block; }
        .reco-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }
        .reco-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .reco-authors {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.75rem;
        }
        .reco-author {
            padding: 0.35rem 0.7rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
        }
        .reco-author:hover {
            border-color: var(--accent);
            background: rgba(255,69,58,0.1);
        }
        
        /* Main content */
        header {
            position: fixed;
            top: 0;
            left: 260px;
            right: 0;
            z-index: 100;
            background: rgba(13,13,13,0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
        }
        .header-inner {
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .header-title {
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--muted);
            white-space: nowrap;
            flex-shrink: 0;
        }
        .header-actions { display: flex; gap: 0.5rem; align-items: center; flex-shrink: 0; }
        .header-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 0.4rem 0.8rem;
            border-radius: 2px;
            font-size: 0.7rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        .header-btn:hover { border-color: var(--text); color: var(--text); }
        
        /* Language selector */
        .lang-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .lang-select {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            padding-right: 1.5rem;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238e8e93' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
        }
        .lang-select:hover { border-color: var(--text); }
        .lang-select:focus { outline: none; border-color: var(--text); }
        .lang-icon { font-size: 0.9rem; }
        
        /* Search Bar */
        .search-container {
            position: relative;
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            margin: 0 1rem;
        }
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        .search-input {
            width: 100%;
            padding: 0.6rem 1rem 0.6rem 2.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 25px;
            color: var(--text);
            font-size: 0.85rem;
            transition: all 0.2s;
            min-width: 150px;
        }
        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(230, 57, 70, 0.1);
        }
        .search-input::placeholder {
            color: var(--muted);
        }
        .search-icon {
            position: absolute;
            left: 0.85rem;
            color: var(--muted);
            font-size: 0.9rem;
            pointer-events: none;
        }
        .search-clear {
            position: absolute;
            right: 0.75rem;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 1rem;
            display: none;
            padding: 0.25rem;
        }
        .search-clear.visible { display: block; }
        .search-clear:hover { color: var(--text); }
        
        main {
            margin-left: 260px;
            max-width: 720px;
            margin-right: auto;
            margin-left: calc(260px + (100% - 260px - 720px) / 2);
            padding: 4.5rem 2rem 4rem;
        }
        @media (max-width: 1100px) {
            main { margin-left: 260px; margin-right: 1rem; }
            .reco-banner { margin-left: 260px; margin-right: 1rem; max-width: none; }
        }
        
        /* Search Results Overlay */
        .search-results-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 400;
            display: none;
            overflow-y: auto;
        }
        .search-results-overlay.open { display: block; }
        .search-results-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        .search-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .search-results-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }
        .search-results-query {
            color: var(--accent);
        }
        .search-results-close {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }
        .search-results-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .search-tab {
            padding: 0.5rem 1rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .search-tab:hover { border-color: var(--text); color: var(--text); }
        .search-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .search-tab .count {
            margin-left: 0.35rem;
            opacity: 0.7;
        }
        .search-results-grid {
            display: grid;
            gap: 1rem;
        }
        .search-result-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .search-result-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }
        .search-result-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.35rem;
        }
        .search-result-author {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }
        .search-result-snippet {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .search-result-snippet mark {
            background: rgba(230, 57, 70, 0.3);
            color: var(--text);
            padding: 0 0.15rem;
            border-radius: 2px;
        }
        .search-result-meta {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.7rem;
            color: var(--muted);
        }
        .search-result-source {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        .search-loading {
            text-align: center;
            padding: 3rem;
            color: var(--muted);
        }
        .search-no-results {
            text-align: center;
            padding: 3rem;
            color: var(--muted);
        }
        .search-no-results-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 3px;
            margin-bottom: 2.5rem;
            overflow: hidden;
            opacity: 0;
            transform: translateY(20px) rotate(-0.3deg);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--accent) 0%, var(--accent-purple) 100%);
        }
        .card:hover { 
            transform: translateY(-2px) rotate(0deg); 
            box-shadow: -8px 8px 0 var(--border);
        }
        .card.show { opacity: 1; transform: rotate(-0.3deg); }
        .card.show:hover { transform: translateY(-2px) rotate(0deg); }
        
        .card-head {
            padding: 1.5rem 1.5rem 0.75rem;
            padding-left: 1.75rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            border-bottom: 1px dashed var(--border);
        }
        .author {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
            letter-spacing: 0.02em;
        }
        .work {
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 0.25rem;
            font-weight: 400;
            font-style: italic;
        }
        .tag {
            font-size: 0.55rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 0.35rem 0.75rem;
            background: transparent;
            color: var(--muted);
            border: 1px solid var(--border);
            border-radius: 0;
        }
        .tag.poésie { border-color: var(--accent-purple); color: var(--accent-purple); }
        .tag.fable { border-color: var(--accent-tertiary); color: var(--accent-tertiary); }
        .tag.nouvelle { border-color: var(--accent-secondary); color: var(--accent-secondary); }
        .tag.mystique { border-color: #c9a227; color: #c9a227; }
        .tag.philosophie { border-color: #8b7355; color: #a08060; }
        .tag.roman { border-color: #c44569; color: #c44569; }
        .tag.théâtre { border-color: #3d9be9; color: #3d9be9; }
        .tag.conte { border-color: var(--accent-secondary); color: var(--accent-secondary); }
        
        /* Ambiances de lecture */
        .ambiance-bar {
            position: sticky;
            top: 52px; /* Hauteur du header */
            z-index: 90;
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            margin-left: 260px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .ambiance-bar::-webkit-scrollbar { display: none; }
        .ambiance-pill {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 1rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .ambiance-pill:hover {
            border-color: var(--text-secondary);
            color: var(--text);
            transform: translateY(-1px);
        }
        .ambiance-pill.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
            box-shadow: 0 2px 8px rgba(255,69,58,0.3);
        }
        .ambiance-pill .ambiance-icon {
            font-size: 1rem;
        }
        .ambiance-pill .ambiance-name {
            font-weight: 500;
        }
        .ambiance-intro {
            position: sticky;
            top: 92px; /* Sous header + barre ambiance */
            z-index: 85;
            padding: 1rem 1.5rem;
            text-align: center;
            background: linear-gradient(135deg, rgba(255,69,58,0.08), rgba(191,90,242,0.08));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            animation: fadeIn 0.5s ease;
            margin-left: 260px;
        }
        .ambiance-intro .close-intro {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .ambiance-intro .close-intro:hover {
            opacity: 1;
        }
        @media (max-width: 900px) {
            .ambiance-intro {
                margin-left: 0;
                top: 88px;
            }
        }
        .ambiance-intro h2 {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }
        .ambiance-intro p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-style: italic;
            max-width: 500px;
            margin: 0 auto;
        }
        .ambiance-intro .ambiance-tags {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }
        .ambiance-intro .ambiance-tag {
            font-size: 0.7rem;
            padding: 0.25rem 0.6rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ambiance-intro .ambiance-tag:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        .ambiance-intro .ambiance-tag.more-authors {
            cursor: default;
            opacity: 0.7;
        }
        .ambiance-intro .ambiance-tag.more-authors:hover {
            background: var(--bg-card);
            color: var(--muted);
            border-color: var(--border);
            transform: none;
        }
        
        /* Language badge */
        .lang-badge {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.25rem 0.5rem;
            background: rgba(255,255,255,0.1);
            color: var(--muted);
            border-radius: 4px;
            margin-left: 0.5rem;
        }
        .lang-badge.en { background: rgba(0,82,180,0.2); color: #64b5f6; }
        .lang-badge.de { background: rgba(255,204,0,0.2); color: #ffd54f; }
        .lang-badge.it { background: rgba(0,140,69,0.2); color: #81c784; }
        .lang-badge.es { background: rgba(198,11,30,0.2); color: #e57373; }
        .lang-badge.pt { background: rgba(0,102,0,0.2); color: #66bb6a; }
        .lang-badge.ru { background: rgba(0,57,166,0.2); color: #7986cb; }
        .lang-badge.la { background: rgba(139,90,43,0.2); color: #bcaaa4; }
        .lang-badge.zh { background: rgba(222,41,16,0.2); color: #ef5350; }
        .lang-badge.ja { background: rgba(188,0,45,0.2); color: #f06292; }
        .lang-badge.ar { background: rgba(0,122,61,0.2); color: #4db6ac; }
        .lang-badge.el { background: rgba(13,94,175,0.2); color: #4fc3f7; }
        
        .card-body {
            padding: 1.25rem 1.5rem 1.25rem 1.75rem;
            font-size: 1.05rem;
            line-height: 1.85;
            position: relative;
            color: var(--text-secondary);
            font-weight: 300;
            cursor: default;
        }
        .card-body .like-heart-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 4rem;
            pointer-events: none;
            opacity: 0;
            z-index: 10;
            filter: drop-shadow(0 0 10px rgba(255,69,58,0.5));
        }
        .card-body .like-heart-overlay.animate {
            animation: likeHeartPop 0.8s ease-out forwards;
        }
        @keyframes likeHeartPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            15% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        .text-teaser {
            white-space: pre-wrap;
        }
        .text-teaser::after {
            content: ' ▪▪▪';
            color: var(--muted);
            font-size: 0.7em;
        }
        .text-full {
            display: none;
            white-space: pre-wrap;
            margin-top: 1.25rem;
            padding-top: 1.25rem;
            border-top: 1px solid var(--border);
            animation: fadeIn 0.4s ease;
        }
        .text-full.visible { display: block; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Bouton Suite - style brutaliste */
        .btn-suite {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 1.25rem;
            padding: 0.6rem 1.25rem;
            background: transparent;
            border: 1px solid var(--accent);
            border-radius: 0;
            color: var(--accent);
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-suite:hover {
            background: var(--accent);
            color: var(--bg);
        }
        .btn-suite.exhausted {
            border-color: var(--muted);
            color: var(--muted);
            cursor: default;
        }
        .btn-suite .arrow {
            transition: transform 0.3s;
        }
        .btn-suite:hover .arrow {
            transform: translateX(3px);
        }
        
        /* Chunks de texte révélés progressivement */
        .text-chunk {
            margin-top: 1rem;
            padding-top: 0.75rem;
        }
        .text-chunk + .text-chunk {
            border-top: 1px dotted var(--border);
        }
        
        .card-foot {
            padding: 1.25rem 1.75rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 0.5rem;
        }
        .actions { display: flex; gap: 0.4rem; }
        .btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 0.5rem 1rem;
            border-radius: 0;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }
        .btn:hover { border-color: var(--text); color: var(--text); }
        .btn.active { 
            background: var(--accent); 
            border-color: var(--accent); 
            color: var(--bg); 
        }
        
        .feed-loading {
            text-align: center;
            padding: 4rem;
            color: var(--muted);
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        .spinner {
            width: 24px;
            height: 24px;
            border: 1px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto 1rem;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-elevated);
            border: 1px solid var(--accent);
            color: var(--text);
            padding: 0.9rem 1.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
            z-index: 300;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .toast.show { transform: translateX(-50%) translateY(0); }
        
        .progress {
            position: fixed;
            top: 0;
            left: 280px;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
            z-index: 1000;
            transition: width 0.1s;
        }
        
        /* Reader overlay */
        .reader-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg);
            z-index: 200;
            display: none;
            flex-direction: column;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .reader-overlay.open { display: flex; }
        .reader-header {
            padding: 1.25rem 2rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .reader-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-weight: 400;
            color: var(--text);
        }
        .reader-close {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text);
            width: 44px;
            height: 44px;
            border-radius: 12px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .reader-close:hover { border-color: var(--accent); color: var(--accent); }
        .reader-content {
            flex: 1;
            overflow-y: auto;
            padding: 3rem 2rem;
            font-size: 1.15rem;
            line-height: 2.2;
            max-width: 700px;
            margin: 0 auto;
            width: 100%;
            font-weight: 300;
        }

        /* Navigateur de Catégories - Barre flottante en bas */
        .category-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            padding-right: 6rem; /* Espace pour le bouton fermer */
            animation: slideUp 0.3s ease;
            z-index: 100;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
            max-height: 40vh;
            overflow-y: auto;
        }
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .cat-breadcrumbs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            font-family: 'Courier Prime', monospace;
        }
        .cat-crumb {
            cursor: pointer;
            color: var(--muted);
            transition: color 0.2s;
        }
        .cat-crumb:hover { color: var(--accent); text-decoration: underline; }
        .cat-crumb.active { color: var(--text); font-weight: bold; pointer-events: none; }
        .cat-sep { color: var(--border); }
        
        .cat-subcategories {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .cat-pill {
            display: inline-flex;
            align-items: center;
            padding: 0.3rem 0.8rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 999px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-secondary);
        }
        .cat-pill:hover {
            border-color: var(--accent);
            color: var(--accent);
            transform: translateY(-2px);
        }
        .cat-pill .count {
            font-size: 0.7em;
            margin-left: 0.4rem;
            opacity: 0.6;
        }
        .cat-close {
            position: absolute;
            top: 0.5rem;
            right: 1rem;
            background: var(--danger);
            border: none;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-weight: 500;
        }
        .cat-close:hover { background: #c0392b; }
        
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--muted);
            font-style: italic;
            line-height: 1.8;
        }
        
        /* Branches enrichies */
        .branches-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .branch-group {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 0.8rem;
            border: 1px solid var(--border);
        }
        .branch-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .branch-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }
        
        /* Favorites View Overlay */
        .favorites-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(13,13,13,0.95);
            z-index: 250;
            display: none;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }
        .favorites-overlay.open { display: block; }
        .favorites-view {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        .favorites-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1.5rem;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        .favorites-title {
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            color: var(--accent);
        }
        .favorites-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .fav-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 4px solid var(--accent);
            padding: 1.5rem;
            transition: all 0.2s;
        }
        .fav-card:hover {
            border-color: var(--accent);
            box-shadow: -4px 4px 0 var(--border);
        }
        .fav-card-head {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .fav-card-author {
            font-family: 'Playfair Display', serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }
        .fav-card-title {
            font-size: 0.8rem;
            color: var(--muted);
            font-style: italic;
            margin-top: 0.25rem;
        }
        .fav-card-text {
            font-size: 0.95rem;
            line-height: 1.8;
            color: var(--text-secondary);
            white-space: pre-wrap;
        }
        .fav-card-actions {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 0.5rem;
        }
        .fav-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--muted);
        }
        .fav-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        .fav-empty-text {
            font-size: 0.8rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        /* Trending view styles */
        .trending-view {
            max-width: 700px;
        }
        .trending-subtitle {
            text-align: center;
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 2rem;
            font-style: italic;
        }
        .trending-feed {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .trending-loading {
            text-align: center;
            padding: 3rem;
            color: var(--muted);
        }
        .trending-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .trending-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        .trending-card-header {
            padding: 1rem 1.25rem;
            background: linear-gradient(135deg, rgba(255,69,58,0.05), rgba(191,90,242,0.05));
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .trending-card-author {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
        }
        .trending-card-author:hover .trending-username {
            color: var(--accent);
        }
        .trending-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
        }
        .trending-username {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
            transition: color 0.2s;
        }
        .trending-time {
            font-size: 0.7rem;
            color: var(--muted);
        }
        .trending-rank {
            font-size: 1.5rem;
            opacity: 0.3;
        }
        .trending-card-body {
            padding: 1.25rem;
        }
        .trending-text {
            font-size: 1.05rem;
            line-height: 1.85;
            color: var(--text);
            font-family: 'Playfair Display', serif;
            white-space: pre-wrap;
            margin-bottom: 1rem;
        }
        .trending-source {
            font-size: 0.8rem;
            color: var(--muted);
            font-style: italic;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .trending-source strong {
            color: var(--text-secondary);
        }
        .trending-card-footer {
            padding: 0.75rem 1.25rem;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .trending-stats {
            display: flex;
            gap: 1.5rem;
        }
        .trending-stat {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.85rem;
            color: var(--muted);
        }
        .trending-stat.hot {
            color: #ff6b6b;
        }
        .trending-actions {
            display: flex;
            gap: 0.5rem;
        }
        .trending-action-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .trending-action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .trending-action-btn.liked {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .trending-empty {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--muted);
        }
        .trending-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        
        /* Bouton favoris dans le header */
        .favorites-btn {
            color: var(--accent) !important;
            border-color: var(--accent) !important;
        }
        .favorites-btn:hover {
            background: var(--accent) !important;
            color: var(--bg) !important;
        }
        
        /* Statistiques de lecture - Design épuré */
        .reading-stats-section {
            background: transparent;
            border: none;
            padding: 0 !important;
        }
        .reading-stats-section h3 {
            display: none;
        }
        .reading-stats-grid {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        .reading-stat-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0;
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--border);
        }
        .reading-stat-item:last-child {
            border-bottom: none;
        }
        .reading-stat-icon {
            font-size: 1.1rem;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-elevated);
            border-radius: 8px;
            flex-shrink: 0;
        }
        .reading-stat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .reading-stat-value {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text);
            line-height: 1.2;
        }
        .reading-stat-label {
            font-size: 0.7rem;
            color: var(--muted);
            line-height: 1.2;
        }
        .streak-item .reading-stat-value {
            color: var(--accent);
        }
        .streak-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .streak-bar {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .streak-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #ff9500);
            width: 0%;
            transition: width 0.5s ease;
        }
        .streak-hint {
            font-size: 0.7rem;
            color: var(--muted);
            text-align: center;
            font-style: italic;
        }
        .weekly-chart {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            height: 40px;
            gap: 4px;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .weekly-bar {
            flex: 1;
            background: var(--border);
            min-height: 4px;
            transition: all 0.3s;
            position: relative;
        }
        .weekly-bar.active {
            background: var(--accent);
        }
        .weekly-bar.today {
            background: linear-gradient(to top, var(--accent), #ff9500);
            box-shadow: 0 0 8px rgba(255,69,58,0.5);
        }
        .weekly-bar::after {
            content: attr(data-day);
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.55rem;
            color: var(--muted);
        }
        
        @media (max-width: 900px) {
            .stats-panel { display: none; }
            header { left: 0; }
            main { margin-left: auto; padding: 5rem 1rem 3rem; }
            .reco-banner { margin-left: 1rem; margin-right: 1rem; max-width: none; }
            .progress { left: 0; }
            .ambiance-bar { margin-left: 0; top: 48px; }
        }
        
        /* Achievement popup */
        .achievement-popup {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: linear-gradient(135deg, rgba(30,30,32,0.98), rgba(20,20,22,0.98));
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 1.25rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(255,69,58,0.3), 0 0 60px rgba(255,69,58,0.1);
            transform: translateX(120%);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .achievement-popup.show { transform: translateX(0); }
        .achievement-icon { font-size: 2.5rem; animation: bounce 0.6s ease infinite; }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .achievement-info { display: flex; flex-direction: column; gap: 0.25rem; }
        .achievement-title { font-size: 0.7rem; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; }
        .achievement-name { font-family: 'Playfair Display', serif; font-size: 1.1rem; font-weight: 600; color: var(--text); }
        .achievement-desc { font-size: 0.8rem; color: var(--text-secondary); }
        
        /* Achievement badges grid - Enhanced */
        .achievements { 
            display: flex; 
            flex-direction: column;
            gap: 0.5rem; 
        }
        .achievement {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .achievement:hover {
            background: var(--bg-card);
            transform: translateX(4px);
        }
        .achievement.locked {
            opacity: 0.6;
        }
        .achievement.locked .badge-icon {
            filter: grayscale(1);
        }
        .achievement.unlocked {
            border-color: var(--accent);
            background: linear-gradient(135deg, rgba(255,69,58,0.1), transparent);
        }
        .achievement.unlocked .badge-icon {
            animation: badgeBounce 2s ease infinite;
        }
        @keyframes badgeBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .badge-icon {
            font-size: 1.8rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-card);
            border-radius: 10px;
            flex-shrink: 0;
        }
        .badge-info {
            flex: 1;
            min-width: 0;
        }
        .badge-name {
            font-family: 'Playfair Display', serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .badge-name .unlocked-check {
            color: #30d158;
            font-size: 0.8rem;
        }
        .badge-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.2rem;
        }
        .badge-progress {
            margin-top: 0.4rem;
        }
        .badge-progress-bar {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        .badge-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #bf5af2);
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        .badge-progress-text {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.2rem;
        }
        .badges-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .badges-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .badges-count span {
            color: var(--accent);
            font-weight: 600;
        }
        .badges-toggle {
            font-size: 0.7rem;
            color: var(--accent);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            transition: background 0.2s;
        }
        .badges-toggle:hover {
            background: rgba(255,69,58,0.1);
        }
        .achievements.collapsed .achievement.locked {
            display: none;
        }
        @keyframes unlockPulse {
            0%, 100% { box-shadow: 0 0 12px rgba(255,69,58,0.3); }
            50% { box-shadow: 0 0 20px rgba(255,69,58,0.5); }
        }
        
        /* Fun stat */
        .fun-stat {
            margin-top: 1rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, rgba(255,69,58,0.1), rgba(191,90,242,0.1));
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            font-style: italic;
            transition: opacity 0.3s;
        }
        
        /* Reading path */
        .reading-path {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.25rem;
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: var(--bg-elevated);
            border-radius: 8px;
            font-size: 0.7rem;
        }
        .path-node {
            background: var(--bg-card);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        .path-node:last-of-type { 
            color: var(--accent); 
            border-color: var(--accent); 
        }
        .path-arrow { color: var(--text-muted); font-size: 0.6rem; }
        
        /* Related authors (dans les cartes) */
        .related-authors {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, rgba(255,69,58,0.05), rgba(191,90,242,0.05));
            border-top: 1px solid var(--border);
        }
        .related-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 500;
        }
        .related-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .related-btn {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .related-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            transform: scale(1.05);
        }
        .no-related {
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .btn-small {
            padding: 0.3rem 0.6rem;
            font-size: 0.75rem;
        }
        .explore-hint {
            font-size: 0.7rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .card-head:hover .explore-hint {
            opacity: 1;
        }
        
        /* ═══════════════════════════════════════════════════════════
           🐦 SOCIAL FEATURES - Style Twitter/X
           ═══════════════════════════════════════════════════════════ */
        
        /* Modal Auth */
        .auth-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }
        .auth-modal.open { display: flex; }
        .auth-box {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            margin: 1rem;
        }
        .auth-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--text);
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .auth-subtitle {
            font-size: 0.85rem;
            color: var(--muted);
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .auth-input {
            width: 100%;
            padding: 0.9rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .auth-input::placeholder { color: var(--muted); }
        .auth-btn {
            width: 100%;
            padding: 0.9rem;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }
        .auth-btn:hover { background: #ff4757; transform: scale(1.02); }
        .auth-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .auth-btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .auth-btn.secondary:hover { border-color: var(--text); color: var(--text); }
        .auth-divider {
            display: flex;
            align-items: center;
            margin: 1.25rem 0;
            color: var(--muted);
            font-size: 0.8rem;
        }
        .auth-divider::before, .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }
        .auth-divider span { padding: 0 1rem; }
        .auth-switch {
            text-align: center;
            margin-top: 1.25rem;
            font-size: 0.85rem;
            color: var(--muted);
        }
        .auth-switch a {
            color: var(--accent);
            cursor: pointer;
            text-decoration: none;
        }
        .auth-switch a:hover { text-decoration: underline; }
        .auth-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--muted);
            font-size: 1.5rem;
            cursor: pointer;
        }
        .auth-close:hover { color: var(--text); }
        .auth-error {
            background: rgba(255,69,58,0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.85rem;
            margin-bottom: 1rem;
            display: none;
        }
        .auth-error.show { display: block; }
        
        /* User menu in header */
        .user-menu {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .user-avatar:hover { border-color: var(--accent); }
        .user-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            min-width: 180px;
            display: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            z-index: 100;
        }
        .user-dropdown.open { display: block; }
        .user-dropdown-item {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .user-dropdown-item:first-child { border-radius: 12px 12px 0 0; }
        .user-dropdown-item:last-child { border-radius: 0 0 12px 12px; }
        .user-dropdown-item:hover {
            background: var(--bg-elevated);
            color: var(--text);
        }
        .user-dropdown-item.danger:hover { color: var(--accent); }
        .user-dropdown-divider {
            height: 1px;
            background: var(--border);
            margin: 0.25rem 0;
        }
        
        /* Social Feed Tab */
        .feed-tabs {
            display: flex;
            gap: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.25rem;
            margin-bottom: 1.5rem;
        }
        .feed-tab {
            flex: 1;
            padding: 0.6rem 1rem;
            background: transparent;
            border: none;
            color: var(--muted);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .feed-tab:hover { color: var(--text); }
        .feed-tab.active {
            background: var(--accent);
            color: white;
        }
        .feed-refresh {
            padding: 0.5rem 0.7rem;
            background: transparent;
            border: none;
            color: var(--muted);
            font-size: 1rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s;
            margin-left: 0.5rem;
        }
        .feed-refresh:hover {
            color: var(--accent);
            transform: rotate(180deg);
        }
        .feed-refresh.spinning {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .feed-live-indicator {
            padding: 0.4rem 1rem;
            font-size: 0.75rem;
            color: var(--muted);
            text-align: center;
            border-bottom: 1px solid var(--border);
        }
        .feed-live-indicator.new-content {
            background: rgba(42, 157, 143, 0.1);
            color: var(--accent);
            cursor: pointer;
        }
        
        /* Share button on cards */
        .btn-share {
            background: transparent;
            border: 1px solid var(--accent-tertiary);
            color: var(--accent-tertiary);
        }
        .btn-share:hover {
            background: var(--accent-tertiary);
            color: var(--bg);
        }
        
        /* Selection highlight for sharing */
        .text-selectable::selection {
            background: rgba(42, 157, 143, 0.4);
        }
        
        /* Share Modal */
        .share-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .share-modal.open { display: flex; }
        .share-box {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            width: 100%;
            max-width: 500px;
            margin: 1rem;
        }
        .share-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .share-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }
        .share-preview {
            background: var(--bg);
            border-left: 3px solid var(--accent-tertiary);
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0 8px 8px 0;
        }
        .share-preview-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-style: italic;
            color: var(--text);
            line-height: 1.6;
            margin-bottom: 0.75rem;
        }
        .share-preview-source {
            font-size: 0.8rem;
            color: var(--muted);
        }
        .share-commentary {
            width: 100%;
            padding: 0.9rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.9rem;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 1rem;
            font-family: inherit;
        }
        .share-commentary:focus { outline: none; border-color: var(--accent-tertiary); }
        .share-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        .share-btn {
            padding: 0.7rem 1.5rem;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .share-btn.primary {
            background: var(--accent-tertiary);
            border: none;
            color: white;
        }
        .share-btn.primary:hover { background: #25877b; }
        .share-btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .share-btn.secondary:hover { border-color: var(--text); color: var(--text); }
        
        /* ═══════════════════════════════════════════════════════════
           💬 COMMENTAIRES
           ═══════════════════════════════════════════════════════════ */
        .comments-section {
            border-top: 1px solid var(--border);
            margin-top: 0.75rem;
            padding-top: 0.75rem;
        }
        .comments-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0.25rem 0;
            transition: color 0.2s;
        }
        .comments-toggle:hover { color: var(--text); }
        .comments-container {
            display: none;
            margin-top: 0.75rem;
        }
        .comments-container.open { display: block; }
        .comments-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 0.75rem;
        }
        .comment-item {
            display: flex;
            gap: 0.6rem;
            padding: 0.6rem 0;
            border-bottom: 1px solid var(--border);
        }
        .comment-item:last-child { border-bottom: none; }
        .comment-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: white;
            font-weight: 600;
            flex-shrink: 0;
        }
        .comment-content {
            flex: 1;
            min-width: 0;
        }
        .comment-header {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            margin-bottom: 0.2rem;
        }
        .comment-username {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
        }
        .comment-username:hover { color: var(--accent); }
        .comment-time {
            font-size: 0.65rem;
            color: var(--muted);
        }
        .comment-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        .comment-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.4rem;
        }
        .comment-like-btn {
            background: none;
            border: none;
            color: var(--muted);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .comment-like-btn:hover {
            background: rgba(255,69,58,0.1);
            color: var(--accent);
        }
        .comment-like-btn.liked {
            color: var(--accent);
        }
        .comment-like-btn.liked .like-icon {
            animation: likePopComment 0.3s ease;
        }
        @keyframes likePopComment {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .comment-like-count {
            font-size: 0.7rem;
            min-width: 12px;
        }
        .comment-delete {
            background: none;
            border: none;
            color: var(--muted);
            font-size: 0.7rem;
            cursor: pointer;
            padding: 0.1rem 0.3rem;
            opacity: 0;
            transition: opacity 0.2s, color 0.2s;
        }
        .comment-item:hover .comment-delete { opacity: 1; }
        .comment-delete:hover { color: #e74c3c; }
        .comment-input-area {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        .comment-input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 0.5rem 0.9rem;
            font-size: 0.8rem;
            color: var(--text);
            outline: none;
            resize: none;
            max-height: 80px;
            min-height: 32px;
        }
        .comment-input:focus { border-color: var(--accent); }
        .comment-send {
            background: var(--accent-tertiary);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 0.8rem;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        .comment-send:hover { transform: scale(1.05); }
        .comment-send:disabled { opacity: 0.5; cursor: not-allowed; }
        .comments-empty {
            text-align: center;
            padding: 1rem;
            color: var(--muted);
            font-size: 0.8rem;
        }
        
        /* Extrait Card (social feed) */
        .extrait-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
            transition: all 0.2s;
        }
        .extrait-card:hover {
            border-color: var(--accent-tertiary);
        }
        .extrait-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .extrait-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            flex-shrink: 0;
        }
        .extrait-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        .extrait-user-info {
            flex: 1;
            min-width: 0;
        }
        .extrait-username {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text);
        }
        .extrait-username-link {
            cursor: pointer;
            transition: color 0.2s;
        }
        .extrait-username-link:hover {
            color: var(--accent);
        }
        .follow-btn {
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            border: 1px solid var(--accent);
            background: transparent;
            color: var(--accent);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }
        .follow-btn:hover {
            background: var(--accent);
            color: white;
        }
        .follow-btn.following {
            background: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
            color: white;
        }
        .follow-btn.following:hover {
            background: #dc3545;
            border-color: #dc3545;
        }
        .user-profile-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            padding: 2rem;
        }
        .user-profile-modal.open {
            opacity: 1;
            visibility: visible;
        }
        .user-profile-content {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 0;
            max-width: 600px;
            width: 100%;
            max-height: 85vh;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .profile-header-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        .profile-header {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .profile-avatar-large {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }
        .profile-info {
            flex: 1;
        }
        .profile-info h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .profile-stats {
            display: flex;
            gap: 1.25rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .profile-stat {
            cursor: pointer;
            transition: color 0.2s;
        }
        .profile-stat:hover {
            color: var(--text);
        }
        .profile-stat strong {
            color: var(--text);
            font-weight: 600;
        }
        .profile-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .profile-actions button {
            padding: 0.6rem 1.25rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
        }
        .btn-follow-large {
            background: var(--accent);
            color: white;
        }
        .btn-follow-large.following {
            background: var(--accent-tertiary);
        }
        .btn-close-profile {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--border) !important;
        }
        .btn-close-profile:hover {
            color: var(--text);
        }
        /* Profile Tabs */
        .profile-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }
        .profile-tab {
            flex: 1;
            padding: 0.85rem 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .profile-tab:hover {
            color: var(--text);
            background: var(--bg-elevated);
        }
        .profile-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        /* Profile Content */
        .profile-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .profile-extraits-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .profile-extrait-card {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }
        .profile-extrait-text {
            font-family: 'Playfair Display', serif;
            font-size: 0.95rem;
            line-height: 1.6;
            color: var(--text);
            margin-bottom: 0.75rem;
            font-style: italic;
        }
        .profile-extrait-source {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .profile-extrait-source strong {
            color: var(--text);
        }
        .profile-extrait-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--muted);
        }
        .profile-empty {
            text-align: center;
            padding: 2rem;
            color: var(--muted);
        }
        .profile-empty-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
        }
        .profile-empty-text {
            font-size: 0.85rem;
        }
        /* Friends list inside profile */
        .friends-list {
            margin-top: 1rem;
        }
        .friends-list h4 {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }
        .friend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .friend-item:hover {
            background: var(--bg-elevated);
        }
        .friend-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
            font-weight: 600;
        }
        .btn-follow-small {
            padding: 0.35rem 0.75rem;
            font-size: 0.7rem;
            border-radius: 20px;
            border: 1px solid var(--accent);
            background: transparent;
            color: var(--accent);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-left: auto;
        }
        .btn-follow-small:hover {
            background: var(--accent);
            color: white;
        }
        .btn-follow-small.following {
            border-color: var(--accent-tertiary);
            color: var(--accent-tertiary);
        }
        .btn-follow-small.following:hover {
            background: rgba(42, 157, 143, 0.2);
        }
        
        /* ═══════════════════════════════════════════════════════════
           💬 MESSAGERIE
           ═══════════════════════════════════════════════════════════ */
        .messages-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 2500;
            display: flex;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        .messages-modal.open {
            opacity: 1;
            visibility: visible;
        }
        .messages-sidebar {
            width: 280px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .messages-sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .messages-sidebar-title {
            font-size: 1rem;
            font-weight: 600;
        }
        .messages-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem;
        }
        .messages-close:hover { color: var(--text); }
        .messages-list {
            flex: 1;
            overflow-y: auto;
        }
        .messages-empty {
            padding: 2rem;
            text-align: center;
            color: var(--muted);
            font-size: 0.85rem;
        }
        .conversation-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.85rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid var(--border);
        }
        .conversation-item:hover {
            background: var(--bg-elevated);
        }
        .conversation-item.active {
            background: var(--bg-elevated);
            border-left: 3px solid var(--accent);
        }
        .conversation-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: white;
            font-weight: 600;
            flex-shrink: 0;
        }
        .conversation-info {
            flex: 1;
            min-width: 0;
        }
        .conversation-name {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .conversation-preview {
            font-size: 0.75rem;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .conversation-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.25rem;
        }
        .conversation-time {
            font-size: 0.65rem;
            color: var(--muted);
        }
        .conversation-unread {
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            font-size: 0.6rem;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }
        .messages-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg);
        }
        .messages-main-empty {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--muted);
            font-size: 0.9rem;
        }
        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: var(--bg-card);
        }
        .chat-header-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            color: white;
            font-weight: 600;
        }
        .chat-header-name {
            font-weight: 500;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .chat-message {
            max-width: 70%;
            padding: 0.65rem 0.9rem;
            border-radius: 16px;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .chat-message.sent {
            align-self: flex-end;
            background: var(--accent);
            color: white;
            border-bottom-right-radius: 4px;
        }
        .chat-message.received {
            align-self: flex-start;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
        }
        .chat-message-time {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.6);
            margin-top: 0.25rem;
            text-align: right;
        }
        .chat-message.received .chat-message-time {
            color: var(--muted);
        }
        .chat-input-area {
            padding: 1rem;
            border-top: 1px solid var(--border);
            background: var(--bg-card);
            display: flex;
            gap: 0.75rem;
        }
        .chat-input {
            flex: 1;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 0.65rem 1rem;
            color: var(--text);
            font-size: 0.85rem;
            outline: none;
        }
        .chat-input:focus {
            border-color: var(--accent);
        }
        .chat-send {
            background: var(--accent);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 1rem;
            transition: transform 0.2s;
        }
        .chat-send:hover {
            transform: scale(1.05);
        }
        .chat-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-message {
            padding: 0.5rem 0.75rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-message:hover {
            border-color: var(--accent-purple);
            color: var(--text);
        }
        .messages-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--accent);
            color: white;
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
        }
        @media (max-width: 700px) {
            .messages-sidebar { width: 100%; }
            .messages-main { display: none; }
            .messages-modal.chat-open .messages-sidebar { display: none; }
            .messages-modal.chat-open .messages-main { display: flex; }
            .chat-back {
                display: block;
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 1.25rem;
                cursor: pointer;
                margin-right: 0.5rem;
            }
        }
        @media (min-width: 701px) {
            .chat-back { display: none; }
        }
        
        /* ═══════════════════════════════════════════════════════════
           🔔 NOTIFICATIONS
           ═══════════════════════════════════════════════════════════ */
        .notif-btn {
            position: relative;
        }
        .notif-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
            min-width: 16px;
            text-align: center;
        }
        .notif-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            width: 320px;
            max-height: 400px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            z-index: 2000;
            display: none;
            overflow: hidden;
        }
        .notif-dropdown.open { display: block; }
        .notif-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .notif-title {
            font-weight: 600;
            font-size: 0.9rem;
        }
        .notif-mark-read {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 0.75rem;
            cursor: pointer;
        }
        .notif-mark-read:hover { text-decoration: underline; }
        .notif-list {
            max-height: 350px;
            overflow-y: auto;
        }
        .notif-empty {
            padding: 2rem;
            text-align: center;
            color: var(--muted);
            font-size: 0.85rem;
        }
        .notif-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid var(--border);
        }
        .notif-item:hover { background: var(--bg-elevated); }
        .notif-item.unread { background: rgba(230, 126, 34, 0.1); }
        .notif-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            color: white;
            font-weight: 600;
            flex-shrink: 0;
        }
        .notif-content {
            flex: 1;
            min-width: 0;
        }
        .notif-text {
            font-size: 0.8rem;
            color: var(--text);
            line-height: 1.4;
        }
        .notif-text strong { color: var(--accent); }
        .notif-time {
            font-size: 0.65rem;
            color: var(--muted);
            margin-top: 0.2rem;
        }
        .notif-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }
        
        /* Discover Users Grid */
        .discover-header {
            text-align: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .discover-header h3 {
            font-size: 1.1rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }
        .discover-header p {
            font-size: 0.85rem;
            color: var(--muted);
        }
        .discover-grid {
            display: grid;
            gap: 0.75rem;
        }
        .discover-card {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            transition: all 0.2s;
        }
        .discover-card:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }
        .discover-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
        }
        .discover-info {
            flex: 1;
            cursor: pointer;
        }
        .discover-name {
            font-weight: 600;
            color: var(--text);
            font-size: 1rem;
        }
        .discover-stats {
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 0.2rem;
        }
        
        /* Feed d'activité */
        .activity-feed {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .activity-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .activity-filter {
            padding: 0.4rem 0.8rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .activity-filter:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        .activity-filter.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .activity-filter .filter-count {
            background: rgba(255,255,255,0.2);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
        }
        .activity-filter.active .filter-count {
            background: rgba(255,255,255,0.3);
        }
        .activity-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .activity-item:hover {
            border-color: var(--accent);
            background: var(--bg-elevated);
        }
        .activity-item.highlight {
            border-color: var(--accent);
            background: linear-gradient(135deg, rgba(255,69,58,0.1), transparent);
            animation: activityHighlight 2s ease;
        }
        @keyframes activityHighlight {
            0% { transform: translateX(-10px); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        .activity-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
        }
        .activity-avatar.comment { background: linear-gradient(135deg, #5ac8fa, #007aff); }
        .activity-avatar.follow { background: linear-gradient(135deg, #bf5af2, #9b59b6); }
        .activity-avatar.share { background: linear-gradient(135deg, #30d158, #27ae60); }
        .activity-content {
            flex: 1;
            min-width: 0;
        }
        .activity-text {
            font-size: 0.9rem;
            color: var(--text);
            line-height: 1.4;
        }
        .activity-text strong {
            color: var(--accent);
            cursor: pointer;
        }
        .activity-text strong:hover {
            text-decoration: underline;
        }
        .activity-snippet {
            font-size: 0.8rem;
            color: var(--muted);
            font-style: italic;
            margin-top: 0.3rem;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .activity-comment-preview {
            font-size: 0.8rem;
            color: var(--text);
            margin-top: 0.3rem;
            padding: 0.5rem;
            background: var(--bg-elevated);
            border-radius: 8px;
            border-left: 2px solid var(--accent);
        }
        .activity-time {
            font-size: 0.75rem;
            color: var(--muted);
            margin-top: 0.25rem;
        }
        .activity-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .activity-icon.like { animation: heartPulse 1s ease infinite; }
        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .activity-section-title {
            font-size: 0.75rem;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            border-top: 1px solid var(--border);
        }
        .activity-section-title:first-child {
            border-top: none;
            margin-top: 0;
        }
        
        .btn-close-profile {
            background: var(--bg-elevated);
            color: var(--text);
            border: 1px solid var(--border) !important;
        }
        .friends-list {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border);
            padding-top: 1rem;
        }
        .friends-list h4 {
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 0.75rem;
        }
        .friend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            cursor: pointer;
        }
        .friend-item:hover {
            background: var(--bg-elevated);
            margin: 0 -1rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
        }
        .friend-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--accent-purple);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
        }
        .extrait-time {
            font-size: 0.75rem;
            color: var(--muted);
        }
        .extrait-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-style: italic;
            color: var(--text);
            line-height: 1.7;
            padding: 1rem;
            background: var(--bg);
            border-left: 3px solid var(--accent-tertiary);
            border-radius: 0 8px 8px 0;
            margin-bottom: 0.75rem;
        }
        .extrait-source {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        .extrait-source strong {
            color: var(--text);
        }
        .extrait-commentary {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .extrait-actions {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }
        .extrait-action {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: none;
            border: none;
            color: var(--muted);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0.3rem 0;
        }
        .extrait-action:hover { color: var(--text); }
        .extrait-action.liked { color: var(--accent); }
        .extrait-action .icon { font-size: 1.1rem; }
        
        /* Empty social feed */
        .social-empty {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--muted);
        }
        .social-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        .social-empty-title {
            font-size: 1rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }
        .social-empty-text {
            font-size: 0.85rem;
        }
        
        /* Profile section in sidebar */
        .profile-section {
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .profile-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        .profile-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text);
        }
        .profile-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--muted);
        }
        .profile-stat strong {
            color: var(--text);
        }
        .login-prompt {
            text-align: center;
            padding: 0.75rem;
        }
        .login-prompt-text {
            font-size: 0.8rem;
            color: var(--muted);
            margin-bottom: 0.75rem;
        }
        .login-prompt-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .login-prompt-btn:hover { background: #ff4757; }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>
    
    <div class="stats-panel">
        <div class="stats-logo">PALIMPSESTE</div>
        
        <!-- Section Profil Social -->
        <div id="profileSection" class="profile-section">
            <div id="profileLoggedOut" class="login-prompt">
                <div class="login-prompt-text">🐦 Rejoignez la communauté pour partager vos extraits préférés</div>
                <button class="login-prompt-btn" onclick="openAuthModal('login')">Se connecter</button>
            </div>
            <div id="profileLoggedIn" style="display:none;">
                <div class="profile-header">
                    <div class="profile-avatar" id="sidebarAvatar">👤</div>
                    <div>
                        <div class="profile-name" id="sidebarUsername">Utilisateur</div>
                        <div class="profile-stats">
                            <span class="profile-stat"><strong id="myExtraitsCount">0</strong> extraits</span>
                            <span class="profile-stat"><strong id="myLikesCount">0</strong> likes</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats-section">
            <h3>🎲 Votre dérive</h3>
            <div class="big-number" id="totalRead">0</div>
            <div class="big-number-label">textes traversés</div>
            <div class="mini-stats">
                <div class="mini-stat">
                    <div class="mini-stat-value" id="likeCountPanel">0</div>
                    <div class="mini-stat-label">coups de ❤️</div>
                </div>
                <div class="mini-stat">
                    <div class="mini-stat-value" id="authorCount">0</div>
                    <div class="mini-stat-label">auteurs</div>
                </div>
            </div>
            <div class="fun-stat" id="funStat"></div>
        </div>
        
        <div class="stats-section reading-stats-section">
            <h3>📊 Lecture</h3>
            <div class="reading-stats-grid">
                <div class="reading-stat-item">
                    <div class="reading-stat-icon">⏱️</div>
                    <div class="reading-stat-content">
                        <div class="reading-stat-value" id="totalReadingTime">0 min</div>
                        <div class="reading-stat-label">temps de lecture</div>
                    </div>
                </div>
                <div class="reading-stat-item">
                    <div class="reading-stat-icon">📖</div>
                    <div class="reading-stat-content">
                        <div class="reading-stat-value" id="totalWordsRead">0</div>
                        <div class="reading-stat-label">mots lus</div>
                    </div>
                </div>
                <div class="reading-stat-item streak-item">
                    <div class="reading-stat-icon">🔥</div>
                    <div class="reading-stat-content">
                        <div class="reading-stat-value" id="currentStreak">0</div>
                        <div class="reading-stat-label">jours d'affilée</div>
                    </div>
                </div>
            </div>
            <div class="streak-section">
                <div class="streak-bar">
                    <div class="streak-progress" id="streakProgress"></div>
                </div>
                <div class="streak-hint" id="streakHint">Continuez demain !</div>
            </div>
            <div class="weekly-chart" id="weeklyChart"></div>
        </div>
        
        <div class="stats-section">
            <h3>🗺️ Territoire exploré</h3>
            <div class="author-bars" id="authorBars"></div>
        </div>
        
        <div class="stats-section">
            <h3>Genres explorés</h3>
            <div class="genre-chart" id="genreChart"></div>
        </div>
        
        <div class="stats-section connections-section" id="connectionsSection" style="display:none;">
            <h3>🕸️ Fils à tirer</h3>
            <p class="connections-hint">Cliquez pour vous perdre...</p>
            <div class="connection-graph" id="connectionGraph"></div>
        </div>
        
        <div class="stats-section favorites-section" id="favoritesSection">
            <h3>💎 Mes favoris</h3>
            <div id="favoritesList"><div class="favorites-empty">Cliquez ♥ pour sauvegarder</div></div>
        </div>
        
        <div class="stats-section" id="achievementSection">
            <h3>🏆 Badges</h3>
            <div class="badges-summary">
                <span class="badges-count"><span id="unlockedCount">0</span>/<span id="totalBadges">13</span> débloqués</span>
                <span class="badges-toggle" id="badgesToggle" onclick="toggleBadgesView()">Voir tout</span>
            </div>
            <div class="achievements" id="achievementList"></div>
            <div class="reading-path" id="readingPath"></div>
        </div>
    </div>
    
    <header>
        <div class="header-inner">
            <div class="header-title" id="headerTitle">Laissez-vous dériver...</div>
            
            <!-- Search Bar -->
            <div class="search-container">
                <div class="search-input-wrapper">
                    <span class="search-icon">🔍</span>
                    <input type="text" class="search-input" id="searchInput" 
                           placeholder="Rechercher un auteur, un mot, un thème..." 
                           onkeydown="if(event.key==='Enter') performSearch()">
                    <button class="search-clear" id="searchClear" onclick="clearSearch()">✕</button>
                </div>
            </div>
            
            <div class="header-actions">
                <button class="header-btn" onclick="pureRandomJump()" title="Découvrir un texte au hasard (ignore l'ambiance)">🎲 Hasard</button>
                <button class="header-btn" onclick="openTrendingFeed()" title="Textes populaires du moment">🔥 Tendances</button>
                <div class="lang-selector">
                    <span class="lang-icon">🌍</span>
                    <select class="lang-select" id="langSelect" onchange="changeLanguage(this.value)" title="Choisir les langues">
                        <option value="all">Toutes langues</option>
                        <option value="fr">🇫🇷 Français</option>
                        <option value="en">🇬🇧 English</option>
                        <option value="de">🇩🇪 Deutsch</option>
                        <option value="it">🇮🇹 Italiano</option>
                        <option value="es">🇪🇸 Español</option>
                        <option value="pt">🇵🇹 Português</option>
                        <option value="ru">🇷🇺 Русский</option>
                        <option value="la">🏛️ Latina</option>
                        <option value="zh">🇨🇳 中文</option>
                        <option value="ja">🇯🇵 日本語</option>
                        <option value="ar">🇸🇦 العربية</option>
                        <option value="el">🇬🇷 Ελληνικά</option>
                    </select>
                </div>
                <button class="header-btn favorites-btn" onclick="openFavoritesView()" title="Voir tous mes favoris">♥ <span id="favCount">0</span></button>
                <button class="header-btn" onclick="openSocialFeed()" title="Voir le feed communautaire">🐦 Social</button>
                <button class="header-btn" onclick="openMessaging()" title="Messages privés" style="position: relative;">💬<span id="unreadBadge" class="messages-badge" style="display: none;">0</span></button>
                <!-- Notifications -->
                <div class="notif-btn" style="position: relative;">
                    <button class="header-btn" onclick="toggleNotifications()" title="Notifications">🔔<span id="notifBadge" class="notif-badge" style="display: none;">0</span></button>
                    <div class="notif-dropdown" id="notifDropdown">
                        <div class="notif-header">
                            <span class="notif-title">🔔 Notifications</span>
                            <button class="notif-mark-read" onclick="markAllNotifsRead()">Tout marquer lu</button>
                        </div>
                        <div class="notif-list" id="notifList">
                            <div class="notif-empty">Aucune notification</div>
                        </div>
                    </div>
                </div>
                <!-- User Menu -->
                <div class="user-menu" id="userMenu">
                    <div class="user-avatar" id="headerAvatar" onclick="toggleUserDropdown()">👤</div>
                    <div class="user-dropdown" id="userDropdown">
                        <div class="user-dropdown-item" onclick="openAuthModal('login')" id="loginMenuItem">🔑 Se connecter</div>
                        <div class="user-dropdown-item" onclick="openAuthModal('register')" id="registerMenuItem">✍️ Créer un compte</div>
                        <div class="user-dropdown-item" onclick="openMyProfile()" id="profileMenuItem" style="display:none;">👤 Mon profil</div>
                        <div class="user-dropdown-divider" id="logoutDivider" style="display:none;"></div>
                        <div class="user-dropdown-item danger" onclick="logoutUser()" id="logoutMenuItem" style="display:none;">🚪 Déconnexion</div>
                    </div>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Navigateur de Catégories (Barre flottante en bas - hors du header) -->
    <div id="categoryNav" class="category-nav" style="display:none;">
        <div class="cat-breadcrumbs" id="catBreadcrumbs"></div>
        <div class="cat-subcategories" id="catSubcategories"></div>
        <button class="cat-close" onclick="closeCategoryMode()">✕ Quitter</button>
    </div>
    
    <!-- Barre d'ambiances de lecture -->
    <div class="ambiance-bar" id="ambianceBar">
        <div class="ambiance-pill active" data-ambiance="libre" onclick="setAmbiance('libre')">
            <span class="ambiance-icon">🌊</span>
            <span class="ambiance-name">Dérive libre</span>
        </div>
        <div class="ambiance-pill" data-ambiance="gothique" onclick="setAmbiance('gothique')">
            <span class="ambiance-icon">🦇</span>
            <span class="ambiance-name">Gothique</span>
        </div>
        <div class="ambiance-pill" data-ambiance="surrealiste" onclick="setAmbiance('surrealiste')">
            <span class="ambiance-icon">🎭</span>
            <span class="ambiance-name">Surréaliste</span>
        </div>
        <div class="ambiance-pill" data-ambiance="romantique" onclick="setAmbiance('romantique')">
            <span class="ambiance-icon">🌹</span>
            <span class="ambiance-name">Romantique</span>
        </div>
        <div class="ambiance-pill" data-ambiance="melancolie" onclick="setAmbiance('melancolie')">
            <span class="ambiance-icon">🌧️</span>
            <span class="ambiance-name">Mélancolie</span>
        </div>
        <div class="ambiance-pill" data-ambiance="mystique" onclick="setAmbiance('mystique')">
            <span class="ambiance-icon">🔮</span>
            <span class="ambiance-name">Mystique</span>
        </div>
        <div class="ambiance-pill" data-ambiance="epique" onclick="setAmbiance('epique')">
            <span class="ambiance-icon">⚔️</span>
            <span class="ambiance-name">Épique</span>
        </div>
        <div class="ambiance-pill" data-ambiance="pastoral" onclick="setAmbiance('pastoral')">
            <span class="ambiance-icon">🌾</span>
            <span class="ambiance-name">Pastoral</span>
        </div>
        <div class="ambiance-pill" data-ambiance="decadent" onclick="setAmbiance('decadent')">
            <span class="ambiance-icon">💀</span>
            <span class="ambiance-name">Décadent</span>
        </div>
        <div class="ambiance-pill" data-ambiance="antique" onclick="setAmbiance('antique')">
            <span class="ambiance-icon">🏛️</span>
            <span class="ambiance-name">Antique</span>
        </div>
        <div class="ambiance-pill" data-ambiance="voyage" onclick="setAmbiance('voyage')">
            <span class="ambiance-icon">🚢</span>
            <span class="ambiance-name">Voyage</span>
        </div>
        <div class="ambiance-pill" data-ambiance="philosophie" onclick="setAmbiance('philosophie')">
            <span class="ambiance-icon">🧠</span>
            <span class="ambiance-name">Philosophie</span>
        </div>
    </div>
    
    <!-- Intro d'ambiance -->
    <div class="ambiance-intro" id="ambianceIntro" style="display: none;"></div>
    
    <main id="feed"></main>
    <div id="recoBanner" class="reco-banner" style="display:none;">
        <div class="reco-content">
            <div class="reco-title">✨ Auteurs connexes à découvrir</div>
            <div class="reco-text">Basé sur vos lectures favorites</div>
            <div class="reco-authors" id="recoAuthors"></div>
        </div>
    </div>
    <div class="feed-loading" id="loading"><div class="spinner"></div><span>Exploration de Wikisource...</span></div>
    
    <div class="reader-overlay" id="reader">
        <div class="reader-header">
            <div class="reader-title" id="readerTitle">Texte complet</div>
            <button class="reader-close" onclick="closeReader()">✕</button>
        </div>
        <div class="reader-content" id="readerContent"></div>
    </div>
    
    <!-- Vue Favoris -->
    <div class="favorites-overlay" id="favoritesOverlay">
        <div class="favorites-view">
            <div class="favorites-header">
                <div class="favorites-title">♥ MES FAVORIS</div>
                <button class="reader-close" onclick="closeFavoritesView()">✕</button>
            </div>
            <div class="favorites-grid" id="favoritesGrid"></div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <!-- Modal d'authentification -->
    <div class="auth-modal" id="authModal">
        <div class="auth-box">
            <button class="auth-close" onclick="closeAuthModal()">✕</button>
            
            <!-- Login Form -->
            <div id="loginForm">
                <div class="auth-title">Bon retour 📚</div>
                <div class="auth-subtitle">Connectez-vous pour partager vos extraits</div>
                <div class="auth-error" id="loginError"></div>
                <input type="email" class="auth-input" id="loginEmail" placeholder="Email">
                <input type="password" class="auth-input" id="loginPassword" placeholder="Mot de passe">
                <button class="auth-btn" onclick="loginWithEmail()" id="loginBtn">Se connecter</button>
                <div class="auth-divider"><span>ou</span></div>
                <button class="auth-btn secondary" onclick="loginWithGoogle()">🌐 Continuer avec Google</button>
                <div class="auth-switch">Pas encore de compte ? <a onclick="switchAuthForm('register')">S'inscrire</a></div>
            </div>
            
            <!-- Register Form -->
            <div id="registerForm" style="display:none;">
                <div class="auth-title">Bienvenue 🌟</div>
                <div class="auth-subtitle">Créez votre compte pour rejoindre la communauté</div>
                <div class="auth-error" id="registerError"></div>
                <input type="text" class="auth-input" id="registerUsername" placeholder="Nom d'utilisateur">
                <input type="email" class="auth-input" id="registerEmail" placeholder="Email">
                <input type="password" class="auth-input" id="registerPassword" placeholder="Mot de passe (min. 6 caractères)">
                <button class="auth-btn" onclick="registerWithEmail()" id="registerBtn">Créer mon compte</button>
                <div class="auth-divider"><span>ou</span></div>
                <button class="auth-btn secondary" onclick="loginWithGoogle()">🌐 Continuer avec Google</button>
                <div class="auth-switch">Déjà un compte ? <a onclick="switchAuthForm('login')">Se connecter</a></div>
            </div>
        </div>
    </div>
    
    <!-- Modal de partage d'extrait -->
    <div class="share-modal" id="shareModal">
        <div class="share-box">
            <div class="share-header">
                <div class="share-title">🐦 Partager cet extrait</div>
                <button class="auth-close" onclick="closeShareModal()">✕</button>
            </div>
            <div class="share-preview">
                <div class="share-preview-text" id="sharePreviewText"></div>
                <div class="share-preview-source" id="sharePreviewSource"></div>
            </div>
            <textarea class="share-commentary" id="shareCommentary" placeholder="Ajoutez un commentaire... (optionnel)"></textarea>
            <div class="share-actions">
                <button class="share-btn secondary" onclick="closeShareModal()">Annuler</button>
                <button class="share-btn primary" onclick="publishExtrait()" id="publishBtn">🚀 Publier</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay Tendances (doom scrolling) -->
    <div class="favorites-overlay" id="trendingOverlay">
        <div class="favorites-view trending-view">
            <div class="favorites-header">
                <div class="favorites-title">🔥 TENDANCES DU MOMENT</div>
                <button class="reader-close" onclick="closeTrendingFeed()">✕</button>
            </div>
            <div class="trending-subtitle">Les textes les plus aimés et commentés</div>
            <div class="trending-feed" id="trendingFeed">
                <div class="trending-loading">Chargement des tendances...</div>
            </div>
        </div>
    </div>
    
    <!-- Overlay Feed Social -->
    <div class="favorites-overlay" id="socialOverlay">
        <div class="favorites-view">
            <div class="favorites-header">
                <div class="favorites-title">🐦 FEED COMMUNAUTAIRE</div>
                <button class="reader-close" onclick="closeSocialFeed()">✕</button>
            </div>
            <div class="feed-tabs">
                <button class="feed-tab active" onclick="switchSocialTab('recent')" id="tabRecent">🔥 Récents</button>
                <button class="feed-tab" onclick="switchSocialTab('activity')" id="tabActivity">❤️ Activité</button>
                <button class="feed-tab" onclick="switchSocialTab('friends')" id="tabFriends">👥 Abonnements</button>
                <button class="feed-tab" onclick="switchSocialTab('followers')" id="tabFollowers">💌 Abonnés</button>
                <button class="feed-tab" onclick="switchSocialTab('discover')" id="tabDiscover">🔎 Découvrir</button>
                <button class="feed-tab" onclick="switchSocialTab('mine')" id="tabMine">👤 Mes extraits</button>
                <button class="feed-refresh" onclick="refreshFeed()" id="refreshBtn" title="Actualiser">🔄</button>
            </div>
            <div class="feed-live-indicator" id="liveIndicator">🟢 En direct</div>
            <div id="socialFeed"></div>
        </div>
    </div>

    <!-- Modal Profil Utilisateur -->
    <div class="user-profile-modal" id="userProfileModal" onclick="if(event.target === this) closeUserProfile()">
        <div class="user-profile-content">
            <div class="profile-header-section">
                <div class="profile-header">
                    <div class="profile-avatar-large" id="profileAvatar">?</div>
                    <div class="profile-info">
                        <h3 id="profileUsername">Utilisateur</h3>
                        <div class="profile-stats">
                            <span class="profile-stat" onclick="switchProfileTab('followers')"><strong id="profileFollowers">0</strong> abonnés</span>
                            <span class="profile-stat" onclick="switchProfileTab('following')"><strong id="profileFollowing">0</strong> abonnements</span>
                            <span class="profile-stat" onclick="switchProfileTab('extraits')"><strong id="profileExtraits">0</strong> extraits</span>
                        </div>
                    </div>
                </div>
                <div class="profile-actions">
                    <button class="btn-follow-large" id="profileFollowBtn" onclick="toggleFollowFromProfile()">Suivre</button>
                    <button class="btn-message" id="profileMessageBtn" onclick="startConversation(currentProfileUserId)">💬 Message</button>
                    <button class="btn-close-profile" onclick="closeUserProfile()">✕ Fermer</button>
                </div>
            </div>
            <div class="profile-tabs">
                <button class="profile-tab active" id="tabProfileExtraits" onclick="switchProfileTab('extraits')">📝 Extraits</button>
                <button class="profile-tab" id="tabProfileLikes" onclick="switchProfileTab('likes')">❤️ Likes</button>
                <button class="profile-tab" id="tabProfileFollowers" onclick="switchProfileTab('followers')">👥 Abonnés</button>
                <button class="profile-tab" id="tabProfileFollowing" onclick="switchProfileTab('following')">📤 Abonnements</button>
            </div>
            <div class="profile-content" id="profileContentArea">
                <!-- Content loaded dynamically -->
            </div>
        </div>
    </div>
    
    <!-- 💬 Modal de Messagerie -->
    <div class="messages-modal" id="messagesModal">
        <div class="messages-sidebar">
            <div class="messages-sidebar-header">
                <span class="messages-sidebar-title">💬 Messages</span>
                <button class="messages-close" onclick="closeMessaging()">✕</button>
            </div>
            <div class="messages-list" id="conversationsList">
                <div class="messages-empty">Chargement...</div>
            </div>
        </div>
        <div class="messages-main">
            <div class="messages-main-empty" id="chatPlaceholder">
                Sélectionnez une conversation
            </div>
            <div id="chatArea" style="display: none; flex-direction: column; height: 100%;">
                <div class="chat-header">
                    <button class="chat-back" onclick="backToConversations()">←</button>
                    <div class="chat-header-avatar" id="chatAvatar">?</div>
                    <div class="chat-header-name" id="chatUsername">Utilisateur</div>
                </div>
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages loaded dynamically -->
                </div>
                <div class="chat-input-area">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Écrire un message..." onkeypress="if(event.key === 'Enter') sendMessage()">
                    <button class="chat-send" id="chatSendBtn" onclick="sendMessage()">➤</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Search Results Overlay -->
    <div class="search-results-overlay" id="searchResultsOverlay" onclick="if(event.target === this) closeSearchResults()">
        <div class="search-results-container">
            <div class="search-results-header">
                <div class="search-results-title">
                    🔍 Résultats pour "<span class="search-results-query" id="searchQueryDisplay"></span>"
                </div>
                <button class="search-results-close" onclick="closeSearchResults()">✕</button>
            </div>
            <div class="search-results-tabs" id="searchResultsTabs"></div>
            <div class="search-results-grid" id="searchResultsGrid"></div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════
        // 🐦 SUPABASE - Configuration Social
        // ═══════════════════════════════════════════════════════════
        
        const SUPABASE_URL = 'https://cqoepdrqifilqxnvflyy.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxb2VwZHJxaWZpbHF4bnZmbHl5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkxNzQxMTksImV4cCI6MjA4NDc1MDExOX0.e7dJmzUEgzDIix12ca38HvBmF7Cgp_fTZPT6gZ6Xy5s';
        
        // Client Supabase (initialisé si configuré)
        let supabaseClient = null;
        let currentUser = null;
        let socialExtraits = [];
        let currentSocialTab = 'recent';
        
        // Vérifie si Supabase est configuré
        function isSupabaseConfigured() {
            return SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY';
        }
        
        // Initialise Supabase si configuré
        function initSupabase() {
            if (!isSupabaseConfigured()) {
                // Mode local uniquement
                return false;
            }
            try {
                // Vérifier que le SDK est chargé
                if (typeof window.supabase === 'undefined') {
                    // SDK pas encore chargé - retry
                    // Réessayer dans 500ms (le SDK est en async)
                    setTimeout(initSupabase, 500);
                    return false;
                }
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                // Supabase prêt
                
                // Écouter les changements d'auth
                supabaseClient.auth.onAuthStateChange((event, session) => {
                    // Auth state changed
                    if (session?.user) {
                        currentUser = session.user;
                        onUserLoggedIn();
                    } else {
                        currentUser = null;
                        onUserLoggedOut();
                    }
                });
                
                // Vérifier si déjà connecté
                checkSession();
                return true;
            } catch (e) {
                console.error('Erreur init Supabase:', e);
                return false;
            }
        }
        
        async function checkSession() {
            if (!supabaseClient) return;
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                onUserLoggedIn();
            }
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🔐 AUTHENTIFICATION
        // ═══════════════════════════════════════════════════════════
        
        function openAuthModal(mode = 'login') {
            document.getElementById('authModal').classList.add('open');
            switchAuthForm(mode);
            closeUserDropdown();
        }
        
        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('open');
            // Reset errors
            document.getElementById('loginError').classList.remove('show');
            document.getElementById('registerError').classList.remove('show');
        }
        
        function switchAuthForm(mode) {
            document.getElementById('loginForm').style.display = mode === 'login' ? 'block' : 'none';
            document.getElementById('registerForm').style.display = mode === 'register' ? 'block' : 'none';
        }
        
        async function loginWithEmail() {
            if (!supabaseClient) {
                showAuthError('login', 'Supabase non configuré. Voir console pour instructions.');
                return;
            }
            
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showAuthError('login', 'Veuillez remplir tous les champs');
                return;
            }
            
            document.getElementById('loginBtn').disabled = true;
            
            const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
            
            document.getElementById('loginBtn').disabled = false;
            
            if (error) {
                showAuthError('login', error.message);
            } else {
                closeAuthModal();
                toast('✅ Connexion réussie !');
            }
        }
        
        async function registerWithEmail() {
            if (!supabaseClient) {
                showAuthError('register', 'Supabase non configuré. Voir console pour instructions.');
                return;
            }
            
            const username = document.getElementById('registerUsername').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            
            if (!username || !email || !password) {
                showAuthError('register', 'Veuillez remplir tous les champs');
                return;
            }
            
            if (password.length < 6) {
                showAuthError('register', 'Le mot de passe doit faire au moins 6 caractères');
                return;
            }
            
            document.getElementById('registerBtn').disabled = true;
            
            const { data, error } = await supabaseClient.auth.signUp({
                email,
                password,
                options: {
                    data: { username }
                }
            });
            
            document.getElementById('registerBtn').disabled = false;
            
            if (error) {
                showAuthError('register', error.message);
            } else {
                // Créer le profil utilisateur
                await createUserProfile(data.user.id, username);
                closeAuthModal();
                toast('🎉 Compte créé ! Vérifiez votre email.');
            }
        }
        
        async function loginWithGoogle() {
            if (!supabaseClient) {
                toast('⚠️ Supabase non configuré');
                return;
            }
            
            const { data, error } = await supabaseClient.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: window.location.origin
                }
            });
            
            if (error) {
                toast('❌ Erreur: ' + error.message);
            }
        }
        
        async function logoutUser() {
            if (!supabaseClient) return;
            
            await supabaseClient.auth.signOut();
            closeUserDropdown();
            toast('👋 Déconnecté');
        }
        
        function showAuthError(form, message) {
            const el = document.getElementById(form + 'Error');
            el.textContent = message;
            el.classList.add('show');
        }
        
        async function createUserProfile(userId, username) {
            if (!supabaseClient) return;
            
            try {
                // Utiliser upsert pour créer ou mettre à jour le profil
                const { error } = await supabaseClient.from('profiles').upsert({
                    id: userId,
                    username: username,
                    created_at: new Date().toISOString()
                }, { onConflict: 'id' });
                
                if (error) {
                    console.error('Erreur création profil:', error);
                }
            } catch (e) {
                console.error('Exception création profil:', e);
            }
        }
        
        // S'assurer que le profil existe (appelé à chaque connexion)
        async function ensureProfileExists() {
            if (!supabaseClient || !currentUser) return;
            
            // Vérifier si le profil existe
            const { data: profile } = await supabaseClient
                .from('profiles')
                .select('id, username')
                .eq('id', currentUser.id)
                .maybeSingle();
            
            if (!profile) {
                // Profil n'existe pas, le créer
                const username = currentUser.user_metadata?.username || 
                                 currentUser.email?.split('@')[0] || 
                                 'Utilisateur';
                await createUserProfile(currentUser.id, username);
            } else if (!profile.username && currentUser.user_metadata?.username) {
                // Profil existe mais sans username, le mettre à jour
                await supabaseClient
                    .from('profiles')
                    .update({ username: currentUser.user_metadata.username })
                    .eq('id', currentUser.id);
            }
        }
        
        // Callbacks auth
        async function onUserLoggedIn() {
            // S'assurer que le profil existe dans la table profiles
            await ensureProfileExists();
            
            const username = currentUser.user_metadata?.username || currentUser.email?.split('@')[0] || 'Utilisateur';
            const initial = username.charAt(0).toUpperCase();
            
            // Update header
            document.getElementById('headerAvatar').innerHTML = initial;
            document.getElementById('loginMenuItem').style.display = 'none';
            document.getElementById('registerMenuItem').style.display = 'none';
            document.getElementById('profileMenuItem').style.display = 'block';
            document.getElementById('logoutDivider').style.display = 'block';
            document.getElementById('logoutMenuItem').style.display = 'block';
            
            // Update sidebar
            document.getElementById('profileLoggedOut').style.display = 'none';
            document.getElementById('profileLoggedIn').style.display = 'block';
            document.getElementById('sidebarAvatar').innerHTML = initial;
            document.getElementById('sidebarUsername').textContent = username;
            
            // Load user stats
            loadUserStats();
            
            // Mettre à jour le badge de messages non lus
            updateUnreadBadge();
            
            // Mettre à jour le badge de notifications et s'abonner
            updateNotifBadge();
            subscribeToNotifications();
        }
        
        function onUserLoggedOut() {
            document.getElementById('headerAvatar').innerHTML = '👤';
            document.getElementById('loginMenuItem').style.display = 'block';
            document.getElementById('registerMenuItem').style.display = 'block';
            document.getElementById('profileMenuItem').style.display = 'none';
            document.getElementById('logoutDivider').style.display = 'none';
            document.getElementById('logoutMenuItem').style.display = 'none';
            
            document.getElementById('profileLoggedOut').style.display = 'block';
            document.getElementById('profileLoggedIn').style.display = 'none';
        }
        
        function toggleUserDropdown() {
            document.getElementById('userDropdown').classList.toggle('open');
        }
        
        function closeUserDropdown() {
            document.getElementById('userDropdown').classList.remove('open');
        }
        
        // Fermer dropdown si clic ailleurs
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.user-menu')) {
                closeUserDropdown();
            }
        });
        
        // ═══════════════════════════════════════════════════════════
        // 🔥 TENDANCES - Feed doom scrolling des textes populaires
        // ═══════════════════════════════════════════════════════════
        
        function openTrendingFeed() {
            document.getElementById('trendingOverlay').classList.add('open');
            loadTrendingFeed();
        }
        
        function closeTrendingFeed() {
            document.getElementById('trendingOverlay').classList.remove('open');
        }
        
        async function loadTrendingFeed() {
            const container = document.getElementById('trendingFeed');
            container.innerHTML = '<div class="trending-loading">🔥 Chargement des tendances...</div>';
            
            if (!supabaseClient) {
                container.innerHTML = '<div class="trending-empty"><div class="trending-empty-icon">🔌</div><p>Connexion requise pour voir les tendances</p></div>';
                return;
            }
            
            try {
                // Charger les extraits les plus likés et commentés récemment
                const { data: extraits, error } = await supabaseClient
                    .from('extraits')
                    .select(`
                        *,
                        profiles:user_id (username, avatar_url)
                    `)
                    .order('likes_count', { ascending: false })
                    .order('comments_count', { ascending: false })
                    .order('created_at', { ascending: false })
                    .limit(30);
                
                if (error) throw error;
                
                if (!extraits || extraits.length === 0) {
                    container.innerHTML = `
                        <div class="trending-empty">
                            <div class="trending-empty-icon">📭</div>
                            <p>Aucun texte populaire pour le moment</p>
                            <p style="font-size: 0.8rem; margin-top: 0.5rem;">Soyez le premier à partager un extrait !</p>
                        </div>
                    `;
                    return;
                }
                
                // Vérifier les likes de l'utilisateur actuel
                const userId = currentUser?.id;
                let userLikes = new Set();
                if (userId) {
                    const { data: likes } = await supabaseClient
                        .from('likes')
                        .select('extrait_id')
                        .eq('user_id', userId);
                    userLikes = new Set((likes || []).map(l => l.extrait_id));
                }
                
                container.innerHTML = extraits.map((extrait, index) => {
                    const username = extrait.profiles?.username || 'Anonyme';
                    const avatar = extrait.profiles?.avatar_url || username[0].toUpperCase();
                    const isLiked = userLikes.has(extrait.id);
                    const likesCount = extrait.likes_count || 0;
                    const commentsCount = extrait.comments_count || 0;
                    const isHot = likesCount >= 5 || commentsCount >= 3;
                    const timeAgo = formatTimeAgo(new Date(extrait.created_at));
                    const rankEmoji = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`;
                    
                    return `
                        <div class="trending-card" data-extrait-id="${extrait.id}">
                            <div class="trending-card-header">
                                <div class="trending-card-author" onclick="openUserProfile('${extrait.user_id}')">
                                    <div class="trending-avatar">${avatar.startsWith('http') ? `<img src="${avatar}" style="width:100%;height:100%;border-radius:50%;">` : avatar}</div>
                                    <div>
                                        <div class="trending-username">${escapeHtml(username)}</div>
                                        <div class="trending-time">${timeAgo}</div>
                                    </div>
                                </div>
                                <div class="trending-rank">${rankEmoji}</div>
                            </div>
                            <div class="trending-card-body">
                                <div class="trending-text">${escapeHtml(extrait.texte)}</div>
                                ${extrait.source_author || extrait.source_title ? `
                                    <div class="trending-source">
                                        <strong>${escapeHtml(extrait.source_author || '')}</strong>
                                        ${extrait.source_title ? ` — ${escapeHtml(extrait.source_title)}` : ''}
                                    </div>
                                ` : ''}
                            </div>
                            <div class="trending-card-footer">
                                <div class="trending-stats">
                                    <div class="trending-stat ${isHot ? 'hot' : ''}">
                                        <span>${isHot ? '🔥' : '❤️'}</span>
                                        <span>${likesCount}</span>
                                    </div>
                                    <div class="trending-stat">
                                        <span>💬</span>
                                        <span>${commentsCount}</span>
                                    </div>
                                </div>
                                <div class="trending-actions">
                                    <button class="trending-action-btn ${isLiked ? 'liked' : ''}" onclick="toggleLikeTrending('${extrait.id}', this)">
                                        ${isLiked ? '❤️' : '🤍'} Like
                                    </button>
                                    <button class="trending-action-btn" onclick="viewTrendingComments('${extrait.id}')">
                                        💬 Commenter
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (err) {
                console.error('Erreur chargement tendances:', err);
                container.innerHTML = '<div class="trending-empty"><div class="trending-empty-icon">⚠️</div><p>Erreur de chargement</p></div>';
            }
        }
        
        async function toggleLikeTrending(extraitId, btn) {
            if (!currentUser) {
                toast('🔐 Connectez-vous pour liker');
                return;
            }
            
            const isLiked = btn.classList.contains('liked');
            
            try {
                if (isLiked) {
                    await supabaseClient
                        .from('likes')
                        .delete()
                        .eq('extrait_id', extraitId)
                        .eq('user_id', currentUser.id);
                    btn.classList.remove('liked');
                    btn.innerHTML = '🤍 Like';
                } else {
                    await supabaseClient
                        .from('likes')
                        .insert({ extrait_id: extraitId, user_id: currentUser.id });
                    btn.classList.add('liked');
                    btn.innerHTML = '❤️ Like';
                    toast('❤️ Aimé !');
                }
                
                // Update count
                const card = btn.closest('.trending-card');
                const statEl = card.querySelector('.trending-stat');
                const countEl = statEl.querySelector('span:last-child');
                const currentCount = parseInt(countEl.textContent) || 0;
                countEl.textContent = isLiked ? currentCount - 1 : currentCount + 1;
                
            } catch (err) {
                console.error('Erreur like trending:', err);
                toast('❌ Erreur');
            }
        }
        
        function viewTrendingComments(extraitId) {
            // Fermer le trending et ouvrir le social feed sur cet extrait
            closeTrendingFeed();
            openSocialFeed();
            // Scroll to the extrait after a short delay
            setTimeout(() => {
                const card = document.querySelector(`[data-extrait-id="${extraitId}"]`);
                if (card) {
                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    toggleComments(extraitId);
                }
            }, 500);
        }
        
        // ═══════════════════════════════════════════════════════════
        // 📤 PARTAGE D'EXTRAITS
        // ═══════════════════════════════════════════════════════════
        
        let pendingShare = null;
        
        function openShareModal(text, author, title, sourceUrl) {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour partager');
                return;
            }
            
            pendingShare = { text, author, title, sourceUrl };
            
            document.getElementById('sharePreviewText').textContent = text.length > 300 
                ? text.substring(0, 300) + '...' 
                : text;
            document.getElementById('sharePreviewSource').textContent = `— ${author}, ${title}`;
            document.getElementById('shareCommentary').value = '';
            document.getElementById('shareModal').classList.add('open');
        }
        
        function closeShareModal() {
            document.getElementById('shareModal').classList.remove('open');
            pendingShare = null;
        }
        
        async function publishExtrait() {
            if (!supabaseClient || !currentUser || !pendingShare) {
                toast('⚠️ Impossible de publier');
                return;
            }
            
            document.getElementById('publishBtn').disabled = true;
            
            const commentary = document.getElementById('shareCommentary').value.trim();
            
            const { data, error } = await supabaseClient.from('extraits').insert({
                user_id: currentUser.id,
                texte: pendingShare.text.substring(0, 1000), // Limite 1000 chars
                source_title: pendingShare.title,
                source_author: pendingShare.author,
                source_url: pendingShare.sourceUrl || '',
                commentary: commentary || null,
                likes_count: 0,
                created_at: new Date().toISOString()
            });
            
            document.getElementById('publishBtn').disabled = false;
            
            if (error) {
                toast('❌ Erreur: ' + error.message);
            } else {
                closeShareModal();
                toast('🐦 Extrait publié !');
                loadUserStats();
            }
        }
        
        // Fonction pour ajouter un bouton de partage sur la sélection
        function setupTextSelection(cardElement, author, title, sourceUrl) {
            const textElement = cardElement.querySelector('.card-body');
            if (!textElement) return;
            
            textElement.classList.add('text-selectable');
            
            textElement.addEventListener('mouseup', () => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                if (selectedText.length >= 20 && selectedText.length <= 1000) {
                    // Montrer un tooltip ou bouton flottant
                    showShareTooltip(selectedText, author, title, sourceUrl);
                }
            });
        }
        
        let shareTooltip = null;
        
        function showShareTooltip(text, author, title, sourceUrl) {
            hideShareTooltip();
            
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            shareTooltip = document.createElement('div');
            shareTooltip.className = 'share-tooltip';
            shareTooltip.innerHTML = `<button onclick="openShareModal('${text.replace(/'/g, "\\'")}', '${author}', '${title}', '${sourceUrl}')">🐦 Partager</button>`;
            shareTooltip.style.cssText = `
                position: fixed;
                top: ${rect.top - 40}px;
                left: ${rect.left + rect.width/2 - 50}px;
                background: var(--accent-tertiary);
                color: white;
                padding: 0.5rem 1rem;
                border-radius: 8px;
                z-index: 1000;
                cursor: pointer;
                font-size: 0.85rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(shareTooltip);
            
            // Auto-hide après 5s
            setTimeout(hideShareTooltip, 5000);
        }
        
        function hideShareTooltip() {
            if (shareTooltip) {
                shareTooltip.remove();
                shareTooltip = null;
            }
        }
        
        document.addEventListener('mousedown', (e) => {
            if (!e.target.closest('.share-tooltip')) {
                hideShareTooltip();
            }
        });
        
        // ═══════════════════════════════════════════════════════════
        // 📱 FEED SOCIAL
        // ═══════════════════════════════════════════════════════════
        
        let feedSubscription = null;
        let likesSubscription = null;
        let lastFeedUpdate = null;
        
        function openSocialFeed() {
            document.getElementById('socialOverlay').classList.add('open');
            loadSocialFeed();
            setupRealtimeSubscriptions();
        }
        
        function closeSocialFeed() {
            document.getElementById('socialOverlay').classList.remove('open');
            // Cleanup subscriptions when closing
            if (feedSubscription) {
                supabaseClient.removeChannel(feedSubscription);
                feedSubscription = null;
            }
            if (likesSubscription) {
                supabaseClient.removeChannel(likesSubscription);
                likesSubscription = null;
            }
        }
        
        // Setup realtime subscriptions
        function setupRealtimeSubscriptions() {
            if (!supabaseClient || feedSubscription) return;
            
            // Subscribe to new extraits
            feedSubscription = supabaseClient
                .channel('extraits-changes')
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'extraits' },
                    (payload) => {
                        // Nouveau contenu détecté
                        showNewContentIndicator();
                    }
                )
                .subscribe();
            
            // Subscribe to likes changes
            likesSubscription = supabaseClient
                .channel('likes-changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'likes' },
                    (payload) => {
                        // Like détecté
                        showNewContentIndicator();
                    }
                )
                .subscribe();
            
            // Realtime activé
        }
        
        function showNewContentIndicator() {
            const indicator = document.getElementById('liveIndicator');
            indicator.textContent = '🔔 Nouveau contenu disponible - Cliquez pour actualiser';
            indicator.classList.add('new-content');
            indicator.onclick = () => refreshFeed();
        }
        
        async function refreshFeed() {
            const btn = document.getElementById('refreshBtn');
            const indicator = document.getElementById('liveIndicator');
            
            btn.classList.add('spinning');
            indicator.textContent = '🟢 En direct';
            indicator.classList.remove('new-content');
            indicator.onclick = null;
            
            await loadSocialFeed();
            
            setTimeout(() => btn.classList.remove('spinning'), 500);
            toast('🔄 Feed actualisé !');
        }
        
        function switchSocialTab(tab) {
            currentSocialTab = tab;
            document.querySelectorAll('.feed-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
            loadSocialFeed();
        }
        
        async function loadSocialFeed() {
            const container = document.getElementById('socialFeed');
            
            if (!isSupabaseConfigured()) {
                container.innerHTML = `
                    <div class="social-empty">
                        <div class="social-empty-icon">⚙️</div>
                        <div class="social-empty-title">Configuration requise</div>
                        <div class="social-empty-text">
                            Pour activer le feed social, configurez Supabase:<br><br>
                            1. Créez un compte sur <a href="https://supabase.com" target="_blank" style="color:var(--accent)">supabase.com</a><br>
                            2. Créez un nouveau projet<br>
                            3. Copiez l'URL et la clé anon<br>
                            4. Remplacez les valeurs dans le code<br><br>
                            <code style="background:var(--bg);padding:0.5rem;border-radius:4px;display:block;margin-top:1rem;font-size:0.75rem;">
                            const SUPABASE_URL = 'votre_url';<br>
                            const SUPABASE_ANON_KEY = 'votre_clé';
                            </code>
                        </div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '<div class="feed-loading"><div class="spinner"></div><span>Chargement...</span></div>';
            
            let query = supabaseClient
                .from('extraits')
                .select('*, profiles(username)')
                .order('created_at', { ascending: false })
                .limit(50);
            
            if (currentSocialTab === 'activity') {
                // Afficher l'activité récente (likes)
                await loadActivityFeed();
                return;
            } else if (currentSocialTab === 'mine' && currentUser) {
                query = supabaseClient
                    .from('extraits')
                    .select('*, profiles(username)')
                    .eq('user_id', currentUser.id)
                    .order('created_at', { ascending: false });
            } else if (currentSocialTab === 'friends' && currentUser) {
                // Charger les extraits des amis
                await loadUserFollowing();
                
                if (userFollowing.size === 0) {
                    container.innerHTML = `
                        <div class="social-empty">
                            <div class="social-empty-icon">👥</div>
                            <div class="social-empty-title">Aucun ami suivi</div>
                            <div class="social-empty-text">
                                Vous ne suivez personne pour l'instant.<br>
                                Allez dans l'onglet "🔎 Découvrir" pour trouver des utilisateurs !
                            </div>
                        </div>
                    `;
                    return;
                }
                
                query = supabaseClient
                    .from('extraits')
                    .select('*, profiles(username)')
                    .in('user_id', Array.from(userFollowing))
                    .order('created_at', { ascending: false })
                    .limit(50);
            } else if (currentSocialTab === 'discover') {
                // Afficher tous les utilisateurs actifs
                await loadUserFollowing();
                await loadDiscoverUsers();
                return;
            } else if (currentSocialTab === 'followers') {
                // Afficher mes abonnés (qui me suivent)
                await loadMyFollowers();
                return;
            }
            
            const { data, error } = await query;
            
            if (error) {
                container.innerHTML = `<div class="social-empty">❌ Erreur: ${error.message}</div>`;
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = `
                    <div class="social-empty">
                        <div class="social-empty-icon">📭</div>
                        <div class="social-empty-title">Aucun extrait</div>
                        <div class="social-empty-text">
                            ${currentSocialTab === 'mine' 
                                ? "Vous n'avez pas encore partagé d'extraits. Sélectionnez du texte dans une lecture pour partager !"
                                : "Soyez le premier à partager un extrait !"}
                        </div>
                    </div>
                `;
                return;
            }
            
            socialExtraits = data;
            renderSocialFeed();
        }
        
        async function renderSocialFeed() {
            const container = document.getElementById('socialFeed');
            
            // Charger les likes et follows de l'utilisateur
            let userLikes = new Set();
            let likeCounts = {};
            
            if (supabaseClient) {
                // Compter les vrais likes pour chaque extrait depuis la table likes
                const extraitIds = socialExtraits.map(e => e.id);
                const { data: allLikes } = await supabaseClient
                    .from('likes')
                    .select('extrait_id')
                    .in('extrait_id', extraitIds);
                
                // Compter les likes par extrait
                if (allLikes) {
                    allLikes.forEach(like => {
                        likeCounts[like.extrait_id] = (likeCounts[like.extrait_id] || 0) + 1;
                    });
                }
                
                if (currentUser) {
                    const { data } = await supabaseClient
                        .from('likes')
                        .select('extrait_id')
                        .eq('user_id', currentUser.id);
                    userLikes = new Set(data?.map(l => l.extrait_id) || []);
                    
                    // Charger les follows si pas déjà fait
                    await loadUserFollowing();
                }
            }
            
            container.innerHTML = socialExtraits.map(extrait => {
                const username = extrait.profiles?.username || 'Anonyme';
                const initial = username.charAt(0).toUpperCase();
                const timeAgo = formatTimeAgo(new Date(extrait.created_at));
                const isLiked = userLikes.has(extrait.id);
                const realLikeCount = likeCounts[extrait.id] || 0;
                
                return `
                    <div class="extrait-card" data-id="${extrait.id}">
                        <div class="extrait-header">
                            <div class="extrait-avatar" onclick="openUserProfile('${extrait.user_id}', '${username}')" style="cursor:pointer">${initial}</div>
                            <div class="extrait-user-info" onclick="openUserProfile('${extrait.user_id}', '${username}')" style="cursor:pointer">
                                <div class="extrait-username">${username}</div>
                                <div class="extrait-time">${timeAgo}</div>
                            </div>
                            ${currentUser && extrait.user_id !== currentUser.id ? `
                                <button class="btn-follow-small ${userFollowing.has(extrait.user_id) ? 'following' : ''}" onclick="toggleFollow('${extrait.user_id}', event)">
                                    ${userFollowing.has(extrait.user_id) ? '✓ Suivi' : '+ Suivre'}
                                </button>
                            ` : ''}
                        </div>
                        <div class="extrait-text">${escapeHtml(extrait.texte)}</div>
                        <div class="extrait-source">
                            <strong>${escapeHtml(extrait.source_author)}</strong> — ${escapeHtml(extrait.source_title)}
                        </div>
                        ${extrait.commentary ? `<div class="extrait-commentary">${escapeHtml(extrait.commentary)}</div>` : ''}
                        <div class="extrait-actions">
                            <button class="extrait-action ${isLiked ? 'liked' : ''}" onclick="toggleLikeExtrait('${extrait.id}')">
                                <span class="icon">${isLiked ? '❤️' : '🤍'}</span>
                                <span>${realLikeCount}</span>
                            </button>
                            <button class="extrait-action" onclick="copyExtrait('${extrait.id}')">
                                <span class="icon">📋</span>
                                <span>Copier</span>
                            </button>
                        </div>
                        <div class="comments-section">
                            <button class="comments-toggle" onclick="toggleComments('${extrait.id}')">
                                💬 <span id="commentCount-${extrait.id}">${extrait.comments_count || 0}</span> commentaire${(extrait.comments_count || 0) !== 1 ? 's' : ''}
                            </button>
                            <div class="comments-container" id="comments-${extrait.id}">
                                <div class="comments-list" id="commentsList-${extrait.id}">
                                    <div class="comments-empty">Chargement...</div>
                                </div>
                                <div class="comment-input-area">
                                    <textarea class="comment-input" id="commentInput-${extrait.id}" placeholder="Écrire un commentaire..." rows="1" onkeypress="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); postComment('${extrait.id}'); }"></textarea>
                                    <button class="comment-send" onclick="postComment('${extrait.id}')">➤</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function toggleLikeExtrait(extraitId) {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour liker');
                return;
            }
            if (!supabaseClient) return;
            
            try {
                const { data: existing } = await supabaseClient
                    .from('likes')
                    .select('id')
                    .eq('user_id', currentUser.id)
                    .eq('extrait_id', extraitId)
                    .single();
                
                if (existing) {
                    await supabaseClient.from('likes').delete().eq('id', existing.id);
                    toast('💔 Like retiré');
                } else {
                    await supabaseClient.from('likes').insert({
                        user_id: currentUser.id,
                        extrait_id: extraitId,
                        created_at: new Date().toISOString()
                    });
                    toast('❤️ Liké !');
                    
                    // Notifier l'auteur de l'extrait
                    const extrait = socialExtraits.find(e => e.id === extraitId);
                    if (extrait && extrait.user_id !== currentUser.id) {
                        createNotification(extrait.user_id, 'like', extraitId);
                    }
                }
                loadSocialFeed();
            } catch (err) {
                toast('❌ Erreur');
            }
        }
        
        function copyExtrait(extraitId) {
            const extrait = socialExtraits.find(e => e.id === extraitId);
            if (!extrait) return;
            
            const text = `"${extrait.texte}"\n— ${extrait.source_author}, ${extrait.source_title}`;
            navigator.clipboard.writeText(text);
            toast('📋 Extrait copié !');
        }
        
        // ═══════════════════════════════════════════════════════════
        // 💬 COMMENTAIRES
        // ═══════════════════════════════════════════════════════════
        
        // Afficher/masquer les commentaires
        async function toggleComments(extraitId) {
            const container = document.getElementById(`comments-${extraitId}`);
            const isOpen = container.classList.contains('open');
            
            if (isOpen) {
                container.classList.remove('open');
            } else {
                container.classList.add('open');
                await loadComments(extraitId);
            }
        }
        
        // Charger les commentaires d'un extrait
        async function loadComments(extraitId) {
            if (!supabaseClient) return;
            
            const container = document.getElementById(`commentsList-${extraitId}`);
            if (!container) return;
            container.innerHTML = '<div class="comments-empty">Chargement...</div>';
            
            try {
                // Récupérer les commentaires
                const { data: comments, error } = await supabaseClient
                    .from('comments')
                    .select('*')
                    .eq('extrait_id', extraitId)
                    .order('created_at', { ascending: true });
                
                if (error) {
                    console.error('Erreur SQL comments:', error);
                    // Vérifier si c'est une erreur de table non existante
                    if (error.message?.includes('does not exist') || error.code === '42P01') {
                        container.innerHTML = '<div class="comments-empty">⚠️ Table comments non créée.<br><small>Exécutez le SQL dans Supabase.</small></div>';
                    } else {
                        container.innerHTML = '<div class="comments-empty">Erreur: ' + error.message + '</div>';
                    }
                    return;
                }
                
                if (!comments || comments.length === 0) {
                    container.innerHTML = '<div class="comments-empty">Aucun commentaire. Soyez le premier !</div>';
                    return;
                }
                
                // Récupérer les profils des commentateurs
                const userIds = [...new Set(comments.map(c => c.user_id))];
                const { data: profiles } = await supabaseClient
                    .from('profiles')
                    .select('id, username')
                    .in('id', userIds);
                const profileMap = new Map((profiles || []).map(p => [p.id, p]));
                
                // Récupérer les likes de tous les commentaires
                const commentIds = comments.map(c => c.id);
                const { data: commentLikes } = await supabaseClient
                    .from('comment_likes')
                    .select('comment_id, user_id')
                    .in('comment_id', commentIds);
                
                // Compter les likes par commentaire et vérifier si l'utilisateur a liké
                const likesCountMap = new Map();
                const userLikedMap = new Map();
                (commentLikes || []).forEach(like => {
                    likesCountMap.set(like.comment_id, (likesCountMap.get(like.comment_id) || 0) + 1);
                    if (currentUser && like.user_id === currentUser.id) {
                        userLikedMap.set(like.comment_id, true);
                    }
                });
                
                container.innerHTML = comments.map(comment => {
                    const profile = profileMap.get(comment.user_id);
                    const username = profile?.username || 'Anonyme';
                    const initial = username.charAt(0).toUpperCase();
                    const timeAgo = formatTimeAgo(new Date(comment.created_at));
                    const canDelete = currentUser && comment.user_id === currentUser.id;
                    const likeCount = likesCountMap.get(comment.id) || 0;
                    const isLiked = userLikedMap.get(comment.id) || false;
                    
                    return `
                        <div class="comment-item" data-id="${comment.id}">
                            <div class="comment-avatar" onclick="openUserProfile('${comment.user_id}', '${escapeHtml(username)}')" style="cursor:pointer">${initial}</div>
                            <div class="comment-content">
                                <div class="comment-header">
                                    <span class="comment-username" onclick="openUserProfile('${comment.user_id}', '${escapeHtml(username)}')">${escapeHtml(username)}</span>
                                    <span class="comment-time">${timeAgo}</span>
                                    ${canDelete ? `<button class="comment-delete" onclick="deleteComment('${comment.id}', '${extraitId}')">🗑️</button>` : ''}
                                </div>
                                <div class="comment-text">${escapeHtml(comment.content)}</div>
                                <div class="comment-actions">
                                    <button class="comment-like-btn ${isLiked ? 'liked' : ''}" onclick="toggleCommentLike('${comment.id}', '${extraitId}')">
                                        <span class="like-icon">${isLiked ? '❤️' : '🤍'}</span>
                                        <span class="comment-like-count">${likeCount > 0 ? likeCount : ''}</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Mettre à jour le compteur
                const countEl = document.getElementById(`commentCount-${extraitId}`);
                if (countEl) countEl.textContent = comments.length;
                
            } catch (err) {
                console.error('Erreur chargement commentaires:', err);
                container.innerHTML = '<div class="comments-empty">Erreur: ' + (err.message || err) + '</div>';
            }
        }
        
        // Poster un commentaire
        async function postComment(extraitId) {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour commenter');
                return;
            }
            
            if (!supabaseClient) return;
            
            const input = document.getElementById(`commentInput-${extraitId}`);
            const content = input.value.trim();
            
            if (!content) return;
            
            input.value = '';
            
            try {
                const { error } = await supabaseClient
                    .from('comments')
                    .insert({
                        extrait_id: extraitId,
                        user_id: currentUser.id,
                        content: content,
                        created_at: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Erreur insert comment:', error);
                    toast('❌ Erreur: ' + error.message);
                    return;
                }
                
                // Incrémenter le compteur (ignorer les erreurs si la fonction n'existe pas)
                try {
                    await supabaseClient.rpc('increment_comments', { p_extrait_id: extraitId });
                } catch (rpcErr) {
                    console.warn('RPC increment_comments non disponible:', rpcErr);
                }
                
                toast('💬 Commentaire ajouté !');
                
                // Notifier l'auteur de l'extrait
                const extrait = socialExtraits.find(e => e.id === extraitId);
                if (extrait && extrait.user_id !== currentUser.id) {
                    createNotification(extrait.user_id, 'comment', extraitId, content.substring(0, 100));
                }
                
                // Recharger les commentaires
                await loadComments(extraitId);
                
            } catch (err) {
                console.error('Erreur post commentaire:', err);
                toast('❌ Erreur d\'envoi');
            }
        }
        
        // Supprimer un commentaire
        async function deleteComment(commentId, extraitId) {
            if (!currentUser || !supabaseClient) return;
            
            if (!confirm('Supprimer ce commentaire ?')) return;
            
            try {
                const { error } = await supabaseClient
                    .from('comments')
                    .delete()
                    .eq('id', commentId);
                
                if (error) throw error;
                
                // Décrémenter le compteur
                await supabaseClient.rpc('decrement_comments', { p_extrait_id: extraitId });
                
                toast('🗑️ Commentaire supprimé');
                
                // Recharger les commentaires
                await loadComments(extraitId);
                
            } catch (err) {
                console.error('Erreur suppression commentaire:', err);
                toast('❌ Erreur de suppression');
            }
        }
        
        // Liker/Unliker un commentaire
        async function toggleCommentLike(commentId, extraitId) {
            if (!currentUser) {
                openAuthModal('login');
                toast('❤️ Connectez-vous pour liker');
                return;
            }
            
            if (!supabaseClient) return;
            
            try {
                // Vérifier si déjà liké
                const { data: existing } = await supabaseClient
                    .from('comment_likes')
                    .select('id')
                    .eq('comment_id', commentId)
                    .eq('user_id', currentUser.id)
                    .single();
                
                if (existing) {
                    // Unlike
                    await supabaseClient
                        .from('comment_likes')
                        .delete()
                        .eq('id', existing.id);
                } else {
                    // Like
                    await supabaseClient
                        .from('comment_likes')
                        .insert({
                            comment_id: commentId,
                            user_id: currentUser.id,
                            created_at: new Date().toISOString()
                        });
                }
                
                // Rafraîchir l'affichage des commentaires
                await loadComments(extraitId);
                
            } catch (err) {
                console.error('Erreur like commentaire:', err);
            }
        }
        
        async function loadUserStats() {
            if (!supabaseClient || !currentUser) return;
            
            // Compter les extraits
            const { count: extraitCount } = await supabaseClient
                .from('extraits')
                .select('*', { count: 'exact', head: true })
                .eq('user_id', currentUser.id);
            
            // Compter les vrais likes reçus (depuis la table likes)
            const { data: myExtraits } = await supabaseClient
                .from('extraits')
                .select('id')
                .eq('user_id', currentUser.id);
            
            let totalLikes = 0;
            if (myExtraits && myExtraits.length > 0) {
                const extraitIds = myExtraits.map(e => e.id);
                const { count: likesCount } = await supabaseClient
                    .from('likes')
                    .select('*', { count: 'exact', head: true })
                    .in('extrait_id', extraitIds);
                totalLikes = likesCount || 0;
            }
            
            document.getElementById('myExtraitsCount').textContent = extraitCount || 0;
            document.getElementById('myLikesCount').textContent = totalLikes;
            
            // Aussi afficher le nombre d'abonnés
            const { count: followersCount } = await supabaseClient
                .from('follows')
                .select('*', { count: 'exact', head: true })
                .eq('following_id', currentUser.id);
            

        }
        
        // Helpers
        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'À l\'instant';
            if (seconds < 3600) return Math.floor(seconds / 60) + ' min';
            if (seconds < 86400) return Math.floor(seconds / 3600) + ' h';
            if (seconds < 604800) return Math.floor(seconds / 86400) + ' j';
            return date.toLocaleDateString('fr-FR');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function openMyProfile() {
            closeUserDropdown();
            switchSocialTab('mine');
            openSocialFeed();
        }
        
        // ═══════════════════════════════════════════════════════════
        // 👥 SYSTÈME D'AMIS (FOLLOWERS)
        // ═══════════════════════════════════════════════════════════
        
        let currentProfileUserId = null;
        let userFollowing = new Set(); // IDs des personnes qu'on suit
        
        // Charger la liste des personnes qu'on suit
        async function loadUserFollowing() {
            if (!currentUser || !supabaseClient) return;
            
            const { data } = await supabaseClient
                .from('follows')
                .select('following_id')
                .eq('follower_id', currentUser.id);
            
            userFollowing = new Set(data?.map(f => f.following_id) || []);
        }
        
        // Charger et afficher les utilisateurs à découvrir
        async function loadDiscoverUsers() {
            const container = document.getElementById('socialFeed');
            
            if (!supabaseClient) {
                container.innerHTML = '<div class="social-empty">⚠️ Non connecté</div>';
                return;
            }
            
            // Récupérer tous les profils avec leur nombre d'extraits
            const { data: profiles, error } = await supabaseClient
                .from('profiles')
                .select('id, username, created_at')
                .order('created_at', { ascending: false })
                .limit(50);
            
            if (error || !profiles) {
                container.innerHTML = '<div class="social-empty">❌ Erreur lors du chargement</div>';
                return;
            }
            
            // Compter les extraits pour chaque profil
            const profilesWithStats = await Promise.all(profiles.map(async (p) => {
                const { count } = await supabaseClient
                    .from('extraits')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', p.id);
                return { ...p, extraitCount: count || 0 };
            }));
            
            // Filtrer pour ne pas s'afficher soi-même
            const filteredProfiles = profilesWithStats.filter(p => 
                !currentUser || p.id !== currentUser.id
            );
            
            if (filteredProfiles.length === 0) {
                container.innerHTML = `
                    <div class="social-empty">
                        <div class="social-empty-icon">🌱</div>
                        <div class="social-empty-title">Pas encore d'utilisateurs</div>
                        <div class="social-empty-text">Soyez le premier à inviter des amis !</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="discover-header">
                    <h3>👥 Utilisateurs à découvrir</h3>
                    <p>Suivez des personnes pour voir leurs extraits dans l'onglet "Abonnements"</p>
                </div>
                <div class="discover-grid">
                    ${filteredProfiles.map(p => renderUserCard(
                        p.id, 
                        p.username, 
                        `${p.extraitCount} extrait${p.extraitCount > 1 ? 's' : ''}`
                    )).join('')}
                </div>
            `;
        }
        
        // Helper: Générer une carte utilisateur
        function renderUserCard(userId, username, subtitle, showFollowButton = true, toggleFn = 'toggleFollow') {
            const initial = (username || 'A').charAt(0).toUpperCase();
            const safeName = escapeHtml(username || 'Anonyme');
            const isFollowing = userFollowing.has(userId);
            return `
                <div class="discover-card">
                    <div class="discover-avatar" onclick="openUserProfile('${userId}', '${safeName}')">${initial}</div>
                    <div class="discover-info" onclick="openUserProfile('${userId}', '${safeName}')">
                        <div class="discover-name">${safeName}</div>
                        <div class="discover-stats">${subtitle}</div>
                    </div>
                    ${showFollowButton ? `
                        <button class="btn-follow-small ${isFollowing ? 'following' : ''}" onclick="${toggleFn}('${userId}', event)">
                            ${isFollowing ? '✓ Suivi' : '+ Suivre'}
                        </button>
                    ` : ''}
                </div>
            `;
        }
        
        // Charger mes abonnés (les gens qui me suivent)
        async function loadMyFollowers() {
            const container = document.getElementById('socialFeed');
            
            if (!supabaseClient || !currentUser) {
                container.innerHTML = `
                    <div class="social-empty">
                        <div class="social-empty-icon">🔐</div>
                        <div class="social-empty-title">Connexion requise</div>
                        <div class="social-empty-text">Connectez-vous pour voir qui vous suit</div>
                    </div>
                `;
                return;
            }
            
            // Récupérer les followers
            const { data: follows } = await supabaseClient
                .from('follows')
                .select('follower_id, created_at')
                .eq('following_id', currentUser.id)
                .order('created_at', { ascending: false });
            
            if (!follows || follows.length === 0) {
                container.innerHTML = `
                    <div class="social-empty">
                        <div class="social-empty-icon">💌</div>
                        <div class="social-empty-title">Pas encore d'abonnés</div>
                        <div class="social-empty-text">
                            Personne ne vous suit encore.<br>
                            Partagez des extraits pour attirer des lecteurs !
                        </div>
                    </div>
                `;
                return;
            }
            
            // Récupérer les profils des followers
            const followerIds = follows.map(f => f.follower_id);
            const profileMap = new Map();
            
            for (const fid of followerIds) {
                const { data: profile } = await supabaseClient
                    .from('profiles')
                    .select('id, username')
                    .eq('id', fid)
                    .maybeSingle();
                if (profile) {
                    profileMap.set(fid, profile);
                }
            }
            
            // Charger qui on suit pour les boutons
            await loadUserFollowing();
            
            container.innerHTML = `
                <div class="discover-header">
                    <h3>💌 Vos abonnés (${follows.length})</h3>
                    <p>Ces personnes vous suivent et voient vos extraits</p>
                </div>
                <div class="discover-grid">
                    ${follows.map(f => {
                        const profile = profileMap.get(f.follower_id);
                        const username = profile?.username || 'Anonyme';
                        const followedAt = formatTimeAgo(new Date(f.created_at));
                        return renderUserCard(f.follower_id, username, `Vous suit depuis ${followedAt}`);
                    }).join('')}
                </div>
            `;
        }
        
        // Feed d'activité - voir toute l'activité de la communauté
        let activitySubscription = null;
        let currentActivityFilter = 'all'; // 'all', 'following', 'mine', 'likes', 'comments'
        
        async function loadActivityFeed() {
            const container = document.getElementById('socialFeed');
            
            if (!supabaseClient) {
                container.innerHTML = '<div class="social-empty">⚠️ Non connecté</div>';
                return;
            }
            
            // Récupérer les abonnements de l'utilisateur
            let followingIds = [];
            if (currentUser) {
                const { data: following } = await supabaseClient
                    .from('follows')
                    .select('following_id')
                    .eq('follower_id', currentUser.id);
                followingIds = (following || []).map(f => f.following_id);
            }
            
            // Récupérer mes extraits pour savoir quand quelqu'un interagit avec
            let myExtraitIds = [];
            if (currentUser) {
                const { data: myExtraits } = await supabaseClient
                    .from('extraits')
                    .select('id')
                    .eq('user_id', currentUser.id);
                myExtraitIds = (myExtraits || []).map(e => e.id);
            }
            
            // Récupérer les likes récents
            const { data: recentLikes, error: likesError } = await supabaseClient
                .from('likes')
                .select('id, created_at, user_id, extrait_id')
                .order('created_at', { ascending: false })
                .limit(30);
            
            // Récupérer les commentaires récents
            const { data: recentComments, error: commentsError } = await supabaseClient
                .from('comments')
                .select('id, created_at, user_id, extrait_id, content')
                .order('created_at', { ascending: false })
                .limit(30);
            
            // Récupérer les follows récents
            const { data: recentFollows, error: followsError } = await supabaseClient
                .from('follows')
                .select('id, created_at, follower_id, following_id')
                .order('created_at', { ascending: false })
                .limit(20);
            
            // Récupérer les nouveaux extraits partagés
            const { data: recentExtraits, error: extraitsError } = await supabaseClient
                .from('extraits')
                .select('id, created_at, user_id, texte, source_title')
                .order('created_at', { ascending: false })
                .limit(20);
            
            // Combiner toutes les activités avec leur type
            let activities = [];
            
            if (recentLikes) {
                activities.push(...recentLikes.map(l => ({
                    type: 'like',
                    id: `like-${l.id}`,
                    created_at: l.created_at,
                    user_id: l.user_id,
                    extrait_id: l.extrait_id,
                    is_on_mine: myExtraitIds.includes(l.extrait_id)
                })));
            }
            
            if (recentComments) {
                activities.push(...recentComments.map(c => ({
                    type: 'comment',
                    id: `comment-${c.id}`,
                    created_at: c.created_at,
                    user_id: c.user_id,
                    extrait_id: c.extrait_id,
                    content: c.content,
                    is_on_mine: myExtraitIds.includes(c.extrait_id)
                })));
            }
            
            if (recentFollows) {
                activities.push(...recentFollows.map(f => ({
                    type: 'follow',
                    id: `follow-${f.id}`,
                    created_at: f.created_at,
                    user_id: f.follower_id,
                    target_id: f.following_id,
                    is_on_mine: f.following_id === currentUser?.id
                })));
            }
            
            if (recentExtraits) {
                activities.push(...recentExtraits.map(e => ({
                    type: 'share',
                    id: `share-${e.id}`,
                    created_at: e.created_at,
                    user_id: e.user_id,
                    extrait_id: e.id,
                    texte: e.texte,
                    source_title: e.source_title
                })));
            }
            
            // Trier par date
            activities.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            // Compter pour les filtres
            const counts = {
                all: activities.length,
                following: activities.filter(a => followingIds.includes(a.user_id)).length,
                mine: activities.filter(a => a.is_on_mine && a.user_id !== currentUser?.id).length,
                likes: activities.filter(a => a.type === 'like').length,
                comments: activities.filter(a => a.type === 'comment').length
            };
            
            // Appliquer le filtre
            let filtered = activities;
            if (currentActivityFilter === 'following') {
                filtered = activities.filter(a => followingIds.includes(a.user_id));
            } else if (currentActivityFilter === 'mine') {
                filtered = activities.filter(a => a.is_on_mine && a.user_id !== currentUser?.id);
            } else if (currentActivityFilter === 'likes') {
                filtered = activities.filter(a => a.type === 'like');
            } else if (currentActivityFilter === 'comments') {
                filtered = activities.filter(a => a.type === 'comment');
            }
            
            // Limiter à 50 résultats
            filtered = filtered.slice(0, 50);
            
            // Récupérer tous les user IDs nécessaires
            const allUserIds = [...new Set([
                ...filtered.map(a => a.user_id),
                ...filtered.filter(a => a.target_id).map(a => a.target_id)
            ])];
            const { data: users } = await supabaseClient
                .from('profiles')
                .select('id, username')
                .in('id', allUserIds);
            const userMap = new Map((users || []).map(u => [u.id, u]));
            
            // Récupérer tous les extraits nécessaires
            const allExtraitIds = [...new Set(filtered.filter(a => a.extrait_id).map(a => a.extrait_id))];
            const { data: extraits } = await supabaseClient
                .from('extraits')
                .select('id, texte, source_title, user_id')
                .in('id', allExtraitIds);
            const extraitMap = new Map((extraits || []).map(e => [e.id, e]));
            
            // Récupérer les auteurs des extraits
            const extraitAuthorIds = [...new Set((extraits || []).map(e => e.user_id))];
            const { data: authors } = await supabaseClient
                .from('profiles')
                .select('id, username')
                .in('id', extraitAuthorIds);
            const authorMap = new Map((authors || []).map(a => [a.id, a]));
            
            container.innerHTML = `
                <div class="discover-header">
                    <h3>📡 Fil d'activité</h3>
                    <p>Suivez ce qui se passe dans la communauté</p>
                </div>
                <div class="activity-filters">
                    <div class="activity-filter ${currentActivityFilter === 'all' ? 'active' : ''}" onclick="setActivityFilter('all')">
                        🌐 Tout <span class="filter-count">${counts.all}</span>
                    </div>
                    ${currentUser ? `
                        <div class="activity-filter ${currentActivityFilter === 'following' ? 'active' : ''}" onclick="setActivityFilter('following')">
                            👥 Abonnements <span class="filter-count">${counts.following}</span>
                        </div>
                        <div class="activity-filter ${currentActivityFilter === 'mine' ? 'active' : ''}" onclick="setActivityFilter('mine')">
                            🔔 Sur mes extraits <span class="filter-count">${counts.mine}</span>
                        </div>
                    ` : ''}
                    <div class="activity-filter ${currentActivityFilter === 'likes' ? 'active' : ''}" onclick="setActivityFilter('likes')">
                        ❤️ Likes <span class="filter-count">${counts.likes}</span>
                    </div>
                    <div class="activity-filter ${currentActivityFilter === 'comments' ? 'active' : ''}" onclick="setActivityFilter('comments')">
                        💬 Commentaires <span class="filter-count">${counts.comments}</span>
                    </div>
                </div>
                ${filtered.length === 0 ? `
                    <div class="social-empty">
                        <div class="social-empty-icon">${currentActivityFilter === 'following' ? '👥' : currentActivityFilter === 'mine' ? '🔔' : '📡'}</div>
                        <div class="social-empty-title">Pas d'activité</div>
                        <div class="social-empty-text">${
                            currentActivityFilter === 'following' 
                                ? 'Suivez des personnes pour voir leur activité ici !' 
                                : currentActivityFilter === 'mine'
                                    ? 'Partagez des extraits pour voir qui interagit avec !'
                                    : 'Soyez le premier à interagir !'
                        }</div>
                    </div>
                ` : `
                    <div class="activity-feed">
                        ${filtered.map(activity => renderActivityItem(activity, userMap, extraitMap, authorMap)).join('')}
                    </div>
                `}
            `;
            
            // S'abonner aux changements en temps réel
            subscribeToActivityFeed();
        }
        
        // Rendu d'un item d'activité
        function renderActivityItem(activity, userMap, extraitMap, authorMap) {
            const actor = userMap.get(activity.user_id);
            const actorName = actor?.username || 'Quelqu\'un';
            const actorInitial = actorName.charAt(0).toUpperCase();
            const timeAgo = formatTimeAgo(new Date(activity.created_at));
            const highlight = activity.is_on_mine ? 'highlight' : '';
            
            if (activity.type === 'like') {
                const extrait = extraitMap.get(activity.extrait_id);
                const author = extrait ? authorMap.get(extrait.user_id) : null;
                const authorName = author?.username || 'Anonyme';
                const snippet = extrait?.texte?.substring(0, 80) || 'Extrait supprimé';
                
                return `
                    <div class="activity-item ${highlight}" onclick="viewExtraitById('${activity.extrait_id}')">
                        <div class="activity-avatar" onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${actorInitial}</div>
                        <div class="activity-content">
                            <div class="activity-text">
                                <strong onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${escapeHtml(actorName)}</strong> 
                                a aimé un extrait de 
                                <strong onclick="event.stopPropagation(); openUserProfile('${extrait?.user_id}', '${escapeHtml(authorName)}')">${escapeHtml(authorName)}</strong>
                            </div>
                            <div class="activity-snippet">"${escapeHtml(snippet)}${snippet.length >= 80 ? '...' : ''}"</div>
                            <div class="activity-time">${timeAgo}</div>
                        </div>
                        <div class="activity-icon like">❤️</div>
                    </div>
                `;
            }
            
            if (activity.type === 'comment') {
                const extrait = extraitMap.get(activity.extrait_id);
                const author = extrait ? authorMap.get(extrait.user_id) : null;
                const authorName = author?.username || 'Anonyme';
                const commentPreview = activity.content?.substring(0, 100) || '';
                
                return `
                    <div class="activity-item ${highlight}" onclick="viewExtraitById('${activity.extrait_id}')">
                        <div class="activity-avatar comment" onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${actorInitial}</div>
                        <div class="activity-content">
                            <div class="activity-text">
                                <strong onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${escapeHtml(actorName)}</strong> 
                                a commenté un extrait de 
                                <strong onclick="event.stopPropagation(); openUserProfile('${extrait?.user_id}', '${escapeHtml(authorName)}')">${escapeHtml(authorName)}</strong>
                            </div>
                            <div class="activity-comment-preview">"${escapeHtml(commentPreview)}${commentPreview.length >= 100 ? '...' : ''}"</div>
                            <div class="activity-time">${timeAgo}</div>
                        </div>
                        <div class="activity-icon">💬</div>
                    </div>
                `;
            }
            
            if (activity.type === 'follow') {
                const target = userMap.get(activity.target_id);
                const targetName = target?.username || 'Quelqu\'un';
                
                return `
                    <div class="activity-item ${highlight}" onclick="openUserProfile('${activity.target_id}', '${escapeHtml(targetName)}')">
                        <div class="activity-avatar follow" onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${actorInitial}</div>
                        <div class="activity-content">
                            <div class="activity-text">
                                <strong onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${escapeHtml(actorName)}</strong> 
                                s'est abonné à 
                                <strong onclick="event.stopPropagation(); openUserProfile('${activity.target_id}', '${escapeHtml(targetName)}')">${escapeHtml(targetName)}</strong>
                            </div>
                            <div class="activity-time">${timeAgo}</div>
                        </div>
                        <div class="activity-icon">👥</div>
                    </div>
                `;
            }
            
            if (activity.type === 'share') {
                const snippet = activity.texte?.substring(0, 80) || '';
                const source = activity.source_title || 'Source inconnue';
                
                return `
                    <div class="activity-item" onclick="viewExtraitById('${activity.extrait_id}')">
                        <div class="activity-avatar share" onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${actorInitial}</div>
                        <div class="activity-content">
                            <div class="activity-text">
                                <strong onclick="event.stopPropagation(); openUserProfile('${activity.user_id}', '${escapeHtml(actorName)}')">${escapeHtml(actorName)}</strong> 
                                a partagé un extrait
                            </div>
                            <div class="activity-snippet">"${escapeHtml(snippet)}${snippet.length >= 80 ? '...' : ''}"</div>
                            <div class="activity-snippet" style="font-style: normal; color: var(--text-secondary);">📖 ${escapeHtml(source)}</div>
                            <div class="activity-time">${timeAgo}</div>
                        </div>
                        <div class="activity-icon">📝</div>
                    </div>
                `;
            }
            
            return '';
        }
        
        // Changer le filtre d'activité
        function setActivityFilter(filter) {
            currentActivityFilter = filter;
            loadActivityFeed();
        }
        
        // Abonnement temps réel à l'activité (likes, commentaires, follows)
        function subscribeToActivityFeed() {
            if (activitySubscription) return; // Déjà abonné
            
            if (!supabaseClient) return;
            
            activitySubscription = supabaseClient
                .channel('activity-all')
                .on('postgres_changes', 
                    { event: 'INSERT', schema: 'public', table: 'likes' },
                    (payload) => {
                        console.log('Nouveau like détecté:', payload);
                        if (currentSocialTab === 'activity') {
                            loadActivityFeed();
                        }
                    }
                )
                .on('postgres_changes',
                    { event: 'DELETE', schema: 'public', table: 'likes' },
                    (payload) => {
                        console.log('Like supprimé:', payload);
                        if (currentSocialTab === 'activity') {
                            loadActivityFeed();
                        }
                    }
                )
                .on('postgres_changes',
                    { event: 'INSERT', schema: 'public', table: 'comments' },
                    (payload) => {
                        console.log('Nouveau commentaire détecté:', payload);
                        if (currentSocialTab === 'activity') {
                            loadActivityFeed();
                        }
                    }
                )
                .on('postgres_changes',
                    { event: 'INSERT', schema: 'public', table: 'follows' },
                    (payload) => {
                        console.log('Nouvel abonnement détecté:', payload);
                        if (currentSocialTab === 'activity') {
                            loadActivityFeed();
                        }
                    }
                )
                .on('postgres_changes',
                    { event: 'INSERT', schema: 'public', table: 'extraits' },
                    (payload) => {
                        console.log('Nouvel extrait partagé:', payload);
                        if (currentSocialTab === 'activity') {
                            loadActivityFeed();
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Statut abonnement activité:', status);
                });
        }
        
        // Se désabonner quand on quitte
        function unsubscribeFromActivityFeed() {
            if (activitySubscription) {
                activitySubscription.unsubscribe();
                activitySubscription = null;
            }
        }
        
        // Voir un extrait par son ID
        async function viewExtraitById(extraitId) {
            if (!supabaseClient) return;
            
            const { data: extrait } = await supabaseClient
                .from('extraits')
                .select('*, profiles(username)')
                .eq('id', extraitId)
                .single();
            
            if (extrait) {
                socialExtraits = [extrait];
                renderSocialFeed();
            }
        }
        
        // Ouvrir le profil d'un utilisateur
        let currentProfileTab = 'extraits';
        
        async function openUserProfile(userId, username) {
            if (!supabaseClient) return;
            
            currentProfileUserId = userId;
            currentProfileTab = 'extraits';
            
            // Charger les infos du profil
            const { data: profile } = await supabaseClient
                .from('profiles')
                .select('*')
                .eq('id', userId)
                .single();
            
            // Compter les extraits
            const { count: extraitCount } = await supabaseClient
                .from('extraits')
                .select('*', { count: 'exact', head: true })
                .eq('user_id', userId);
            
            // Compter followers/following
            const { count: followersCount } = await supabaseClient
                .from('follows')
                .select('*', { count: 'exact', head: true })
                .eq('following_id', userId);
            
            const { count: followingCount } = await supabaseClient
                .from('follows')
                .select('*', { count: 'exact', head: true })
                .eq('follower_id', userId);
            
            // Mettre à jour l'UI
            const displayName = profile?.username || username || 'Anonyme';
            document.getElementById('profileAvatar').textContent = displayName.charAt(0).toUpperCase();
            document.getElementById('profileUsername').textContent = displayName;
            document.getElementById('profileFollowers').textContent = followersCount || 0;
            document.getElementById('profileFollowing').textContent = followingCount || 0;
            document.getElementById('profileExtraits').textContent = extraitCount || 0;
            
            // Bouton suivre
            const followBtn = document.getElementById('profileFollowBtn');
            const messageBtn = document.getElementById('profileMessageBtn');
            if (currentUser && userId !== currentUser.id) {
                followBtn.style.display = 'inline-block';
                messageBtn.style.display = 'inline-block';
                const isFollowing = userFollowing.has(userId);
                followBtn.textContent = isFollowing ? 'Ne plus suivre' : 'Suivre';
                followBtn.classList.toggle('following', isFollowing);
            } else {
                followBtn.style.display = 'none';
                messageBtn.style.display = 'none';
            }
            
            // Reset tabs
            document.querySelectorAll('.profile-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tabProfileExtraits').classList.add('active');
            
            // Charger le contenu initial (extraits)
            await loadProfileExtraits(userId);
            
            // Ouvrir la modal
            document.getElementById('userProfileModal').classList.add('open');
        }
        
        // Changer d'onglet dans le profil
        async function switchProfileTab(tab) {
            if (!currentProfileUserId) return;
            
            currentProfileTab = tab;
            
            // Update tabs UI
            document.querySelectorAll('.profile-tab').forEach(t => t.classList.remove('active'));
            const tabMap = {
                'extraits': 'tabProfileExtraits',
                'likes': 'tabProfileLikes',
                'followers': 'tabProfileFollowers',
                'following': 'tabProfileFollowing'
            };
            document.getElementById(tabMap[tab])?.classList.add('active');
            
            // Load content
            const container = document.getElementById('profileContentArea');
            container.innerHTML = '<div class="profile-empty"><div class="spinner"></div></div>';
            
            switch(tab) {
                case 'extraits':
                    await loadProfileExtraits(currentProfileUserId);
                    break;
                case 'likes':
                    await loadProfileLikes(currentProfileUserId);
                    break;
                case 'followers':
                    await loadProfileFollowersList(currentProfileUserId);
                    break;
                case 'following':
                    await loadProfileFollowingList(currentProfileUserId);
                    break;
            }
        }
        
        // Charger les extraits partagés par l'utilisateur
        async function loadProfileExtraits(userId) {
            const container = document.getElementById('profileContentArea');
            
            const { data: extraits } = await supabaseClient
                .from('extraits')
                .select('*')
                .eq('user_id', userId)
                .order('created_at', { ascending: false })
                .limit(30);
            
            if (!extraits || extraits.length === 0) {
                container.innerHTML = `
                    <div class="profile-empty">
                        <div class="profile-empty-icon">📝</div>
                        <div class="profile-empty-text">Aucun extrait partagé</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="profile-extraits-list">
                    ${extraits.map(e => `
                        <div class="profile-extrait-card">
                            <div class="profile-extrait-text">"${esc(e.texte.substring(0, 300))}${e.texte.length > 300 ? '...' : ''}"</div>
                            <div class="profile-extrait-source">
                                <strong>${esc(e.source_author)}</strong> — ${esc(e.source_title)}
                            </div>
                            <div class="profile-extrait-meta">
                                <span>❤️ ${e.likes_count || 0} likes</span>
                                <span>${formatTimeAgo(new Date(e.created_at))}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Charger les extraits likés par l'utilisateur
        async function loadProfileLikes(userId) {
            const container = document.getElementById('profileContentArea');
            
            // Récupérer les likes de l'utilisateur
            const { data: likes } = await supabaseClient
                .from('likes')
                .select('extrait_id, created_at')
                .eq('user_id', userId)
                .order('created_at', { ascending: false })
                .limit(30);
            
            if (!likes || likes.length === 0) {
                container.innerHTML = `
                    <div class="profile-empty">
                        <div class="profile-empty-icon">❤️</div>
                        <div class="profile-empty-text">Aucun like pour l'instant</div>
                    </div>
                `;
                return;
            }
            
            // Récupérer les extraits likés
            const extraitIds = likes.map(l => l.extrait_id);
            const { data: extraits } = await supabaseClient
                .from('extraits')
                .select('*, profiles:user_id(username)')
                .in('id', extraitIds);
            
            if (!extraits || extraits.length === 0) {
                container.innerHTML = `
                    <div class="profile-empty">
                        <div class="profile-empty-icon">❤️</div>
                        <div class="profile-empty-text">Aucun extrait disponible</div>
                    </div>
                `;
                return;
            }
            
            // Mapper par ID pour garder l'ordre des likes
            const extraitMap = new Map(extraits.map(e => [e.id, e]));
            
            container.innerHTML = `
                <div class="profile-extraits-list">
                    ${likes.map(l => {
                        const e = extraitMap.get(l.extrait_id);
                        if (!e) return '';
                        const authorName = e.profiles?.username || 'Anonyme';
                        return `
                            <div class="profile-extrait-card">
                                <div class="profile-extrait-text">"${esc(e.texte.substring(0, 300))}${e.texte.length > 300 ? '...' : ''}"</div>
                                <div class="profile-extrait-source">
                                    <strong>${esc(e.source_author)}</strong> — ${esc(e.source_title)}
                                </div>
                                <div class="profile-extrait-meta">
                                    <span>par @${esc(authorName)}</span>
                                    <span>liké ${formatTimeAgo(new Date(l.created_at))}</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        // Charger les abonnés (personnes qui suivent cet utilisateur)
        async function loadProfileFollowersList(userId) {
            const container = document.getElementById('profileContentArea');
            
            const { data } = await supabaseClient
                .from('follows')
                .select('follower_id, created_at, profiles!follows_follower_id_fkey(username)')
                .eq('following_id', userId)
                .order('created_at', { ascending: false })
                .limit(50);
            
            if (!data || data.length === 0) {
                container.innerHTML = `
                    <div class="profile-empty">
                        <div class="profile-empty-icon">👥</div>
                        <div class="profile-empty-text">Aucun abonné pour l'instant</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="friends-list">
                    ${data.map(f => {
                        const name = f.profiles?.username || 'Anonyme';
                        return `
                            <div class="friend-item" onclick="openUserProfile('${f.follower_id}', '${esc(name)}')">
                                <div class="friend-avatar">${name.charAt(0).toUpperCase()}</div>
                                <span>${esc(name)}</span>
                                <span style="margin-left:auto; font-size:0.7rem; color:var(--muted)">depuis ${formatTimeAgo(new Date(f.created_at))}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        // Charger les personnes suivies par un utilisateur
        async function loadProfileFollowingList(userId) {
            const container = document.getElementById('profileContentArea');
            
            const { data } = await supabaseClient
                .from('follows')
                .select('following_id, created_at, profiles!follows_following_id_fkey(username)')
                .eq('follower_id', userId)
                .order('created_at', { ascending: false })
                .limit(50);
            
            if (!data || data.length === 0) {
                container.innerHTML = `
                    <div class="profile-empty">
                        <div class="profile-empty-icon">📤</div>
                        <div class="profile-empty-text">Ne suit personne pour l'instant</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="friends-list">
                    ${data.map(f => {
                        const name = f.profiles?.username || 'Anonyme';
                        return `
                            <div class="friend-item" onclick="openUserProfile('${f.following_id}', '${esc(name)}')">
                                <div class="friend-avatar">${name.charAt(0).toUpperCase()}</div>
                                <span>${esc(name)}</span>
                                <span style="margin-left:auto; font-size:0.7rem; color:var(--muted)">depuis ${formatTimeAgo(new Date(f.created_at))}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        // Fermer la modal profil
        function closeUserProfile() {
            document.getElementById('userProfileModal').classList.remove('open');
            currentProfileUserId = null;
        }
        
        // Suivre/Ne plus suivre depuis la modal profil
        async function toggleFollowFromProfile() {
            if (!currentProfileUserId) return;
            await toggleFollow(currentProfileUserId);
            
            // Rafraîchir l'affichage
            const followBtn = document.getElementById('profileFollowBtn');
            const isNowFollowing = userFollowing.has(currentProfileUserId);
            followBtn.textContent = isNowFollowing ? 'Ne plus suivre' : 'Suivre';
            followBtn.classList.toggle('following', isNowFollowing);
            
            // Mettre à jour le compteur followers
            const { count } = await supabaseClient
                .from('follows')
                .select('*', { count: 'exact', head: true })
                .eq('following_id', currentProfileUserId);
            document.getElementById('profileFollowers').textContent = count || 0;
        }
        
        // Suivre/Ne plus suivre un utilisateur
        async function toggleFollow(userId, event) {
            if (event) event.stopPropagation();
            
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour suivre');
                return;
            }
            
            if (!supabaseClient || userId === currentUser.id) return;
            
            const isFollowing = userFollowing.has(userId);
            
            if (isFollowing) {
                // Unfollow
                await supabaseClient
                    .from('follows')
                    .delete()
                    .eq('follower_id', currentUser.id)
                    .eq('following_id', userId);
                userFollowing.delete(userId);
                toast('👋 Vous ne suivez plus cet utilisateur');
            } else {
                // Follow
                await supabaseClient
                    .from('follows')
                    .insert({
                        follower_id: currentUser.id,
                        following_id: userId,
                        created_at: new Date().toISOString()
                    });
                userFollowing.add(userId);
                toast('✅ Vous suivez maintenant cet utilisateur !');
                
                // Notifier l'utilisateur qu'on le suit
                createNotification(userId, 'follow');
            }
            
            // Rafraîchir le feed si on est sur l'onglet amis
            if (currentSocialTab === 'friends') {
                loadSocialFeed();
            }
        }
        
        // ═══════════════════════════════════════════════════════════
        // 💬 MESSAGERIE PRIVÉE
        // ═══════════════════════════════════════════════════════════
        
        let currentConversationUserId = null;
        let messagesSubscription = null;
        
        // Ouvrir la messagerie
        async function openMessaging() {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour accéder à vos messages');
                return;
            }
            
            document.getElementById('messagesModal').classList.add('open');
            document.getElementById('messagesModal').classList.remove('chat-open');
            document.getElementById('chatArea').style.display = 'none';
            document.getElementById('chatPlaceholder').style.display = 'flex';
            
            await loadConversations();
            subscribeToMessages();
        }
        
        // Fermer la messagerie
        function closeMessaging() {
            document.getElementById('messagesModal').classList.remove('open');
            if (messagesSubscription) {
                messagesSubscription.unsubscribe();
                messagesSubscription = null;
            }
            currentConversationUserId = null;
        }
        
        // Retour aux conversations (mobile)
        function backToConversations() {
            document.getElementById('messagesModal').classList.remove('chat-open');
            document.getElementById('chatArea').style.display = 'none';
            document.getElementById('chatPlaceholder').style.display = 'flex';
            currentConversationUserId = null;
        }
        
        // Charger les conversations
        async function loadConversations() {
            if (!supabaseClient || !currentUser) return;
            
            const container = document.getElementById('conversationsList');
            container.innerHTML = '<div class="messages-empty">Chargement...</div>';
            
            try {
                // Récupérer tous les messages où l'utilisateur est impliqué
                // Utiliser deux requêtes séparées pour éviter les problèmes de syntaxe OR
                const { data: sentMessages, error: err1 } = await supabaseClient
                    .from('messages')
                    .select('*')
                    .eq('sender_id', currentUser.id);
                
                const { data: receivedMessages, error: err2 } = await supabaseClient
                    .from('messages')
                    .select('*')
                    .eq('receiver_id', currentUser.id);
                
                if (err1 || err2) {
                    console.error('Erreur messages:', err1 || err2);
                    // Vérifier si c'est une erreur de table non existante
                    const errMsg = (err1 || err2)?.message || '';
                    if (errMsg.includes('does not exist') || errMsg.includes('relation')) {
                        container.innerHTML = '<div class="messages-empty">⚠️ La table messages n\'existe pas encore.<br><br>Exécutez le SQL dans Supabase pour activer la messagerie.</div>';
                    } else {
                        container.innerHTML = '<div class="messages-empty">Erreur de chargement<br><small>' + errMsg + '</small></div>';
                    }
                    return;
                }
                
                // Combiner et trier
                const allMessages = [...(sentMessages || []), ...(receivedMessages || [])];
                allMessages.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                if (allMessages.length === 0) {
                    container.innerHTML = '<div class="messages-empty">Aucune conversation.<br><br>Visitez le profil d\'un utilisateur et cliquez sur "💬 Message" pour démarrer une conversation.</div>';
                    return;
                }
                
                // Grouper par conversation (autre utilisateur)
                const conversations = new Map();
                for (const msg of allMessages) {
                    const otherUserId = msg.sender_id === currentUser.id ? msg.receiver_id : msg.sender_id;
                    if (!conversations.has(otherUserId)) {
                        conversations.set(otherUserId, {
                            otherUserId,
                            lastMessage: msg,
                            unreadCount: 0
                        });
                    }
                    // Compter les messages non lus
                    if (msg.receiver_id === currentUser.id && !msg.read_at) {
                        const conv = conversations.get(otherUserId);
                        conv.unreadCount++;
                    }
                }
                
                // Récupérer les profils des autres utilisateurs
                const userIds = Array.from(conversations.keys());
                const { data: profiles } = await supabaseClient
                    .from('profiles')
                    .select('id, username')
                    .in('id', userIds);
                
                const profileMap = new Map();
                (profiles || []).forEach(p => profileMap.set(p.id, p));
                
                // Afficher les conversations
                container.innerHTML = '';
                for (const [userId, conv] of conversations) {
                    const profile = profileMap.get(userId) || { username: 'Utilisateur' };
                    const initial = profile.username.charAt(0).toUpperCase();
                    const preview = conv.lastMessage.content.substring(0, 40) + (conv.lastMessage.content.length > 40 ? '...' : '');
                    const time = formatMessageTime(conv.lastMessage.created_at);
                    
                    const item = document.createElement('div');
                    item.className = 'conversation-item';
                    if (currentConversationUserId === userId) item.classList.add('active');
                    item.onclick = () => openConversation(userId, profile.username);
                    item.innerHTML = `
                        <div class="conversation-avatar">${initial}</div>
                        <div class="conversation-info">
                            <div class="conversation-name">${profile.username}</div>
                            <div class="conversation-preview">${conv.lastMessage.sender_id === currentUser.id ? 'Vous: ' : ''}${preview}</div>
                        </div>
                        <div class="conversation-meta">
                            <span class="conversation-time">${time}</span>
                            ${conv.unreadCount > 0 ? `<span class="conversation-unread">${conv.unreadCount}</span>` : ''}
                        </div>
                    `;
                    container.appendChild(item);
                }
            } catch (err) {
                console.error('Erreur chargement conversations:', err);
                container.innerHTML = '<div class="messages-empty">Erreur de chargement<br><small>' + (err.message || err) + '</small></div>';
            }
        }
        
        // Formater l'heure des messages
        function formatMessageTime(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'À l\'instant';
            if (diff < 3600000) return Math.floor(diff / 60000) + ' min';
            if (diff < 86400000) return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            if (diff < 604800000) return date.toLocaleDateString('fr-FR', { weekday: 'short' });
            return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
        }
        
        // Ouvrir une conversation
        async function openConversation(userId, username) {
            currentConversationUserId = userId;
            
            // Afficher le chat
            document.getElementById('chatPlaceholder').style.display = 'none';
            document.getElementById('chatArea').style.display = 'flex';
            document.getElementById('messagesModal').classList.add('chat-open');
            
            // Header
            document.getElementById('chatAvatar').textContent = username.charAt(0).toUpperCase();
            document.getElementById('chatUsername').textContent = username;
            
            // Charger les messages
            await loadMessages(userId);
            
            // Marquer comme lus
            markMessagesAsRead(userId);
            
            // Mettre à jour la liste (active)
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            loadConversations(); // Refresh pour les badges
        }
        
        // Charger les messages d'une conversation
        async function loadMessages(otherUserId) {
            if (!supabaseClient || !currentUser) return;
            
            const container = document.getElementById('chatMessages');
            container.innerHTML = '<div class="messages-empty">Chargement...</div>';
            
            try {
                // Récupérer les messages envoyés et reçus séparément
                const { data: sentMessages, error: err1 } = await supabaseClient
                    .from('messages')
                    .select('*')
                    .eq('sender_id', currentUser.id)
                    .eq('receiver_id', otherUserId);
                
                const { data: receivedMessages, error: err2 } = await supabaseClient
                    .from('messages')
                    .select('*')
                    .eq('sender_id', otherUserId)
                    .eq('receiver_id', currentUser.id);
                
                if (err1 || err2) throw (err1 || err2);
                
                // Combiner et trier par date
                const messages = [...(sentMessages || []), ...(receivedMessages || [])];
                messages.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                container.innerHTML = '';
                
                if (messages.length === 0) {
                    container.innerHTML = '<div class="messages-empty" style="align-self: center; margin: auto;">Démarrez la conversation !</div>';
                    return;
                }
                
                for (const msg of messages) {
                    const isSent = msg.sender_id === currentUser.id;
                    const msgEl = document.createElement('div');
                    msgEl.className = `chat-message ${isSent ? 'sent' : 'received'}`;
                    msgEl.innerHTML = `
                        ${escapeHtml(msg.content)}
                        <div class="chat-message-time">${formatMessageTime(msg.created_at)}</div>
                    `;
                    container.appendChild(msgEl);
                }
                
                // Scroll en bas
                container.scrollTop = container.scrollHeight;
            } catch (err) {
                console.error('Erreur chargement messages:', err);
                container.innerHTML = '<div class="messages-empty">Erreur de chargement</div>';
            }
        }
        
        // Envoyer un message
        async function sendMessage() {
            if (!supabaseClient || !currentUser || !currentConversationUserId) return;
            
            const input = document.getElementById('chatInput');
            const content = input.value.trim();
            
            if (!content) return;
            
            input.value = '';
            
            try {
                const { error } = await supabaseClient
                    .from('messages')
                    .insert({
                        sender_id: currentUser.id,
                        receiver_id: currentConversationUserId,
                        content: content,
                        created_at: new Date().toISOString()
                    });
                
                if (error) throw error;
                
                // Rafraîchir les messages
                await loadMessages(currentConversationUserId);
                
            } catch (err) {
                console.error('Erreur envoi message:', err);
                toast('❌ Erreur d\'envoi');
            }
        }
        
        // Marquer les messages comme lus
        async function markMessagesAsRead(fromUserId) {
            if (!supabaseClient || !currentUser) return;
            
            try {
                await supabaseClient
                    .from('messages')
                    .update({ read_at: new Date().toISOString() })
                    .eq('sender_id', fromUserId)
                    .eq('receiver_id', currentUser.id)
                    .is('read_at', null);
                
                updateUnreadBadge();
            } catch (err) {
                console.error('Erreur marquage lu:', err);
            }
        }
        
        // Mettre à jour le badge de messages non lus
        async function updateUnreadBadge() {
            if (!supabaseClient || !currentUser) return;
            
            try {
                const { count } = await supabaseClient
                    .from('messages')
                    .select('*', { count: 'exact', head: true })
                    .eq('receiver_id', currentUser.id)
                    .is('read_at', null);
                
                const badge = document.getElementById('unreadBadge');
                if (count && count > 0) {
                    badge.textContent = count > 99 ? '99+' : count;
                    badge.style.display = 'block';
                } else {
                    badge.style.display = 'none';
                }
            } catch (err) {
                console.error('Erreur comptage non lus:', err);
            }
        }
        
        // Souscrire aux nouveaux messages (temps réel)
        function subscribeToMessages() {
            if (!supabaseClient || !currentUser || messagesSubscription) return;
            
            messagesSubscription = supabaseClient
                .channel('messages-channel')
                .on('postgres_changes', 
                    { event: 'INSERT', schema: 'public', table: 'messages' },
                    (payload) => {
                        const msg = payload.new;
                        if (msg.receiver_id === currentUser.id || msg.sender_id === currentUser.id) {
                            // Rafraîchir la conversation si elle est ouverte
                            if (currentConversationUserId === msg.sender_id || currentConversationUserId === msg.receiver_id) {
                                loadMessages(currentConversationUserId);
                            }
                            // Rafraîchir la liste des conversations
                            loadConversations();
                            // Mettre à jour le badge
                            updateUnreadBadge();
                        }
                    }
                )
                .subscribe();
        }
        
        // Démarrer une conversation (depuis le profil)
        function startConversation(userId) {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour envoyer des messages');
                return;
            }
            
            if (userId === currentUser.id) {
                toast('😅 Vous ne pouvez pas vous écrire à vous-même');
                return;
            }
            
            closeUserProfile();
            openMessaging();
            
            // Ouvrir la conversation avec ce user
            const username = document.getElementById('profileUsername').textContent;
            setTimeout(() => {
                openConversation(userId, username);
            }, 300);
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🔔 NOTIFICATIONS
        // ═══════════════════════════════════════════════════════════
        
        let notificationsSubscription = null;
        
        // Afficher/masquer les notifications
        function toggleNotifications() {
            const dropdown = document.getElementById('notifDropdown');
            const isOpen = dropdown.classList.contains('open');
            
            // Fermer les autres dropdowns
            document.getElementById('userDropdown')?.classList.remove('open');
            
            if (isOpen) {
                dropdown.classList.remove('open');
            } else {
                dropdown.classList.add('open');
                loadNotifications();
            }
        }
        
        // Fermer dropdown quand on clique ailleurs
        document.addEventListener('click', (e) => {
            const notifBtn = document.querySelector('.notif-btn');
            if (notifBtn && !notifBtn.contains(e.target)) {
                document.getElementById('notifDropdown')?.classList.remove('open');
            }
        });
        
        // Charger les notifications
        async function loadNotifications() {
            if (!supabaseClient || !currentUser) return;
            
            const container = document.getElementById('notifList');
            container.innerHTML = '<div class="notif-empty">Chargement...</div>';
            
            try {
                const { data: notifs, error } = await supabaseClient
                    .from('notifications')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('created_at', { ascending: false })
                    .limit(30);
                
                if (error) {
                    console.error('Erreur notifications:', error);
                    if (error.message?.includes('does not exist')) {
                        container.innerHTML = '<div class="notif-empty">⚠️ Table non créée</div>';
                    } else {
                        container.innerHTML = '<div class="notif-empty">Erreur</div>';
                    }
                    return;
                }
                
                if (!notifs || notifs.length === 0) {
                    container.innerHTML = '<div class="notif-empty">Aucune notification</div>';
                    return;
                }
                
                // Récupérer les profils des expéditeurs
                const fromUserIds = [...new Set(notifs.map(n => n.from_user_id))];
                const { data: profiles } = await supabaseClient
                    .from('profiles')
                    .select('id, username')
                    .in('id', fromUserIds);
                const profileMap = new Map((profiles || []).map(p => [p.id, p]));
                
                container.innerHTML = notifs.map(notif => {
                    const fromUser = profileMap.get(notif.from_user_id);
                    const fromName = fromUser?.username || 'Quelqu\'un';
                    const initial = fromName.charAt(0).toUpperCase();
                    const timeAgo = formatTimeAgo(new Date(notif.created_at));
                    const isUnread = !notif.read_at;
                    
                    let icon = '🔔';
                    let text = '';
                    
                    if (notif.type === 'like') {
                        icon = '❤️';
                        text = `<strong>${escapeHtml(fromName)}</strong> a aimé votre extrait`;
                    } else if (notif.type === 'comment') {
                        icon = '💬';
                        text = `<strong>${escapeHtml(fromName)}</strong> a commenté votre extrait`;
                    } else if (notif.type === 'follow') {
                        icon = '👤';
                        text = `<strong>${escapeHtml(fromName)}</strong> vous suit`;
                    }
                    
                    return `
                        <div class="notif-item ${isUnread ? 'unread' : ''}" onclick="handleNotifClick('${notif.id}', '${notif.type}', '${notif.extrait_id || ''}', '${notif.from_user_id}', '${escapeHtml(fromName)}')">
                            <div class="notif-avatar">${initial}</div>
                            <div class="notif-content">
                                <div class="notif-text">${text}</div>
                                <div class="notif-time">${timeAgo}</div>
                            </div>
                            <div class="notif-icon">${icon}</div>
                        </div>
                    `;
                }).join('');
                
            } catch (err) {
                console.error('Erreur chargement notifications:', err);
                container.innerHTML = '<div class="notif-empty">Erreur</div>';
            }
        }
        
        // Gérer le clic sur une notification
        async function handleNotifClick(notifId, type, extraitId, fromUserId, fromName) {
            // Marquer comme lue
            if (supabaseClient && currentUser) {
                await supabaseClient
                    .from('notifications')
                    .update({ read_at: new Date().toISOString() })
                    .eq('id', notifId);
            }
            
            // Fermer le dropdown
            document.getElementById('notifDropdown').classList.remove('open');
            
            // Action selon le type
            if (type === 'like' || type === 'comment') {
                if (extraitId) {
                    viewExtraitById(extraitId);
                }
            } else if (type === 'follow') {
                openUserProfile(fromUserId, fromName);
            }
            
            // Mettre à jour le badge
            updateNotifBadge();
        }
        
        // Marquer toutes les notifications comme lues
        async function markAllNotifsRead() {
            if (!supabaseClient || !currentUser) return;
            
            try {
                await supabaseClient
                    .from('notifications')
                    .update({ read_at: new Date().toISOString() })
                    .eq('user_id', currentUser.id)
                    .is('read_at', null);
                
                toast('✅ Toutes les notifications marquées comme lues');
                loadNotifications();
                updateNotifBadge();
            } catch (err) {
                console.error('Erreur marquage lu:', err);
            }
        }
        
        // Mettre à jour le badge de notifications
        async function updateNotifBadge() {
            if (!supabaseClient || !currentUser) return;
            
            try {
                const { count } = await supabaseClient
                    .from('notifications')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', currentUser.id)
                    .is('read_at', null);
                
                const badge = document.getElementById('notifBadge');
                if (count && count > 0) {
                    badge.textContent = count > 99 ? '99+' : count;
                    badge.style.display = 'block';
                } else {
                    badge.style.display = 'none';
                }
            } catch (err) {
                // Ignorer si la table n'existe pas
            }
        }
        
        // Créer une notification
        async function createNotification(userId, type, extraitId = null, content = null) {
            if (!supabaseClient || !currentUser) return;
            if (userId === currentUser.id) return; // Pas de notif pour soi-même
            
            try {
                await supabaseClient
                    .from('notifications')
                    .insert({
                        user_id: userId,
                        from_user_id: currentUser.id,
                        type: type,
                        extrait_id: extraitId,
                        content: content,
                        created_at: new Date().toISOString()
                    });
            } catch (err) {
                console.warn('Notification non créée:', err);
            }
        }
        
        // S'abonner aux notifications en temps réel
        function subscribeToNotifications() {
            if (!supabaseClient || !currentUser || notificationsSubscription) return;
            
            notificationsSubscription = supabaseClient
                .channel('notif-channel')
                .on('postgres_changes',
                    { event: 'INSERT', schema: 'public', table: 'notifications', filter: `user_id=eq.${currentUser.id}` },
                    (payload) => {
                        console.log('Nouvelle notification:', payload);
                        updateNotifBadge();
                        // Notification visuelle
                        toast('🔔 Nouvelle notification !');
                    }
                )
                .subscribe();
        }

        // Fonction pour partager depuis une carte
        function shareCardExtrait(cardId) {
            const card = document.getElementById(cardId);
            if (!card) return;
            
            const text = card.dataset.text || '';
            const author = card.dataset.author || 'Inconnu';
            const title = card.dataset.title || 'Sans titre';
            
            // Récupérer la sélection si elle existe, sinon utiliser le teaser
            const selection = window.getSelection().toString().trim();
            const textToShare = selection.length >= 20 ? selection : text.substring(0, 500);
            
            // Construire l'URL Wikisource
            const lang = card.dataset.lang || 'fr';
            const sourceUrl = `https://${lang}.wikisource.org/wiki/${encodeURIComponent(title)}`;
            
            openShareModal(textToShare, author, title, sourceUrl);
        }
        
        // Partager rapidement et ouvrir les commentaires
        async function quickShareAndComment(cardId) {
            if (!currentUser) {
                openAuthModal('login');
                toast('📝 Connectez-vous pour commenter');
                return;
            }
            
            const card = document.getElementById(cardId);
            if (!card) return;
            
            const text = card.dataset.text || '';
            const author = card.dataset.author || 'Inconnu';
            const title = card.dataset.title || 'Sans titre';
            const lang = card.dataset.lang || 'fr';
            const sourceUrl = `https://${lang}.wikisource.org/wiki/${encodeURIComponent(title)}`;
            
            // Récupérer la sélection ou le teaser
            const selection = window.getSelection().toString().trim();
            const textToShare = selection.length >= 20 ? selection : text.substring(0, 500);
            
            // Vérifier si cet extrait existe déjà (même texte, même source)
            if (supabaseClient) {
                const { data: existing } = await supabaseClient
                    .from('extraits')
                    .select('id')
                    .eq('texte', textToShare)
                    .eq('source_title', title)
                    .eq('user_id', currentUser.id)
                    .maybeSingle();
                
                if (existing) {
                    // Ouvrir le feed social et afficher cet extrait
                    toast('📖 Cet extrait existe déjà, ouverture...');
                    openSocialFeed();
                    setTimeout(async () => {
                        await viewExtraitById(existing.id);
                        // Ouvrir les commentaires
                        setTimeout(() => toggleComments(existing.id), 300);
                    }, 300);
                    return;
                }
                
                // Créer l'extrait directement
                const { data: newExtrait, error } = await supabaseClient
                    .from('extraits')
                    .insert({
                        user_id: currentUser.id,
                        texte: textToShare,
                        source_title: title,
                        source_author: author,
                        source_url: sourceUrl,
                        commentary: '',
                        created_at: new Date().toISOString()
                    })
                    .select()
                    .single();
                
                if (error) {
                    console.error('Erreur création extrait:', error);
                    toast('❌ Erreur: ' + error.message);
                    return;
                }
                
                toast('✅ Extrait partagé ! Ajoutez votre commentaire');
                
                // Ouvrir le feed social et afficher cet extrait avec les commentaires ouverts
                openSocialFeed();
                setTimeout(async () => {
                    await viewExtraitById(newExtrait.id);
                    // Ouvrir les commentaires automatiquement
                    setTimeout(() => toggleComments(newExtrait.id), 300);
                }, 300);
            }
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🌍 CONFIGURATION MULTILINGUE - Littérature mondiale
        // ═══════════════════════════════════════════════════════════
        const WIKISOURCES = [
            { lang: 'fr', name: 'Français', url: 'https://fr.wikisource.org' },
            { lang: 'en', name: 'English', url: 'https://en.wikisource.org' },
            { lang: 'de', name: 'Deutsch', url: 'https://de.wikisource.org' },
            { lang: 'it', name: 'Italiano', url: 'https://it.wikisource.org' },
            { lang: 'es', name: 'Español', url: 'https://es.wikisource.org' },
            { lang: 'pt', name: 'Português', url: 'https://pt.wikisource.org' },
            { lang: 'ru', name: 'Русский', url: 'https://ru.wikisource.org' },
            { lang: 'la', name: 'Latina', url: 'https://la.wikisource.org' },
            { lang: 'zh', name: '中文', url: 'https://zh.wikisource.org' },
            { lang: 'ja', name: '日本語', url: 'https://ja.wikisource.org' },
            { lang: 'ar', name: 'العربية', url: 'https://ar.wikisource.org' },
            { lang: 'el', name: 'Ελληνικά', url: 'https://el.wikisource.org' },
        ];
        
        // Sources alternatives (APIs propres sans scories)
        const ALT_SOURCES = {
            poetrydb: {
                name: 'PoetryDB',
                url: 'https://poetrydb.org',
                lang: 'en',
                // Auteurs disponibles dans PoetryDB
                authors: ['Shakespeare', 'Emily Dickinson', 'William Blake', 'John Keats', 
                          'Percy Shelley', 'Lord Byron', 'William Wordsworth', 'Edgar Allan Poe',
                          'Walt Whitman', 'Robert Frost', 'Oscar Wilde', 'Alfred Tennyson']
            },
            gutenberg: {
                name: 'Project Gutenberg',
                url: 'https://www.gutenberg.org',
                // Œuvres populaires avec leurs IDs Gutenberg (domaine public)
                works: [
                    { id: 1342, title: 'Pride and Prejudice', author: 'Jane Austen', lang: 'en' },
                    { id: 11, title: 'Alice\'s Adventures in Wonderland', author: 'Lewis Carroll', lang: 'en' },
                    { id: 84, title: 'Frankenstein', author: 'Mary Shelley', lang: 'en' },
                    { id: 1661, title: 'The Adventures of Sherlock Holmes', author: 'Arthur Conan Doyle', lang: 'en' },
                    { id: 2701, title: 'Moby Dick', author: 'Herman Melville', lang: 'en' },
                    { id: 1232, title: 'The Prince', author: 'Niccolò Machiavelli', lang: 'en' },
                    { id: 174, title: 'The Picture of Dorian Gray', author: 'Oscar Wilde', lang: 'en' },
                    { id: 345, title: 'Dracula', author: 'Bram Stoker', lang: 'en' },
                    { id: 1400, title: 'Great Expectations', author: 'Charles Dickens', lang: 'en' },
                    { id: 98, title: 'A Tale of Two Cities', author: 'Charles Dickens', lang: 'en' },
                    { id: 2600, title: 'War and Peace', author: 'Leo Tolstoy', lang: 'en' },
                    { id: 2554, title: 'Crime and Punishment', author: 'Fyodor Dostoevsky', lang: 'en' },
                    { id: 4300, title: 'Ulysses', author: 'James Joyce', lang: 'en' },
                    { id: 1080, title: 'A Modest Proposal', author: 'Jonathan Swift', lang: 'en' },
                    { id: 76, title: 'Adventures of Huckleberry Finn', author: 'Mark Twain', lang: 'en' },
                    { id: 74, title: 'The Adventures of Tom Sawyer', author: 'Mark Twain', lang: 'en' },
                    { id: 219, title: 'Heart of Darkness', author: 'Joseph Conrad', lang: 'en' },
                    { id: 5200, title: 'Metamorphosis', author: 'Franz Kafka', lang: 'en' },
                    { id: 1952, title: 'The Yellow Wallpaper', author: 'Charlotte Perkins Gilman', lang: 'en' },
                    { id: 120, title: 'Treasure Island', author: 'Robert Louis Stevenson', lang: 'en' },
                    // Français
                    { id: 17489, title: 'Les Misérables', author: 'Victor Hugo', lang: 'fr' },
                    { id: 13951, title: 'Le Comte de Monte-Cristo', author: 'Alexandre Dumas', lang: 'fr' },
                    { id: 14287, title: 'Les Trois Mousquetaires', author: 'Alexandre Dumas', lang: 'fr' },
                    { id: 4650, title: 'Du côté de chez Swann', author: 'Marcel Proust', lang: 'fr' },
                    { id: 17396, title: 'Madame Bovary', author: 'Gustave Flaubert', lang: 'fr' },
                    { id: 13704, title: 'Le Rouge et le Noir', author: 'Stendhal', lang: 'fr' },
                    { id: 5053, title: 'Germinal', author: 'Émile Zola', lang: 'fr' },
                    // Autres langues
                    { id: 2000, title: 'Don Quixote', author: 'Miguel de Cervantes', lang: 'es' },
                    { id: 1012, title: 'The Divine Comedy', author: 'Dante Alighieri', lang: 'it' },
                    { id: 2229, title: 'The Sorrows of Young Werther', author: 'Johann Wolfgang von Goethe', lang: 'de' },
                    { id: 7849, title: 'Faust', author: 'Johann Wolfgang von Goethe', lang: 'de' }
                ]
            }
        };
        
        // Mots-clés de recherche par langue (termes qui fonctionnent bien sur Wikisource)
        const SEARCH_TERMS = {
            fr: [
                'Les Fleurs du Mal', 'Fables de La Fontaine', 'Les Contemplations',
                'Baudelaire', 'Hugo poème', 'Verlaine', 'Rimbaud',
                'Maupassant nouvelle', 'Balzac', 'Zola chapitre',
                'Molière acte', 'Racine tragédie', 'La Fontaine fable',
                'Musset poésie', 'Lamartine méditation', 'Nerval sonnet',
                'Flaubert', 'Stendhal', 'Voltaire conte'
            ],
            en: [
                'Shakespeare sonnet', 'Milton Paradise', 'Keats ode',
                'Byron poem', 'Shelley', 'Wordsworth', 'Blake songs',
                'Dickens chapter', 'Austen', 'Poe tale',
                'Whitman leaves', 'Dickinson poem', 'Tennyson'
            ],
            de: [
                'Goethe Faust', 'Schiller', 'Heine Gedicht',
                'Rilke', 'Novalis', 'Hölderlin', 'Grimm Märchen',
                'Kafka', 'Mann Kapitel', 'Nietzsche'
            ],
            it: [
                'Dante Divina', 'Petrarca sonetto', 'Leopardi canto',
                'Manzoni capitolo', 'Boccaccio novella', 'Ariosto',
                'Pirandello', 'Foscolo', 'Carducci'
            ],
            es: [
                'Cervantes Quijote', 'Góngora soneto', 'Quevedo',
                'Lorca poema', 'Machado', 'Bécquer rima',
                'Calderón', 'Lope de Vega'
            ],
            pt: ['Camões soneto', 'Pessoa poema', 'Eça de Queirós', 'Machado de Assis'],
            ru: ['Пушкин стихотворение', 'Толстой глава', 'Достоевский', 'Чехов рассказ', 'Лермонтов'],
            la: ['Vergilius Aeneis', 'Horatius ode', 'Ovidius', 'Cicero', 'Catullus carmen'],
            zh: ['李白 詩', '杜甫', '蘇軾', '白居易'],
            ja: ['芥川龍之介', '夏目漱石', '太宰治', '宮沢賢治'],
            ar: ['المتنبي قصيدة', 'أبو تمام', 'البحتري'],
            el: ['Ομήρου', 'Σαπφώ', 'Πίνδαρος'],
        };
        
        // État de la langue courante ('all' = toutes langues, ou code langue spécifique)
        let selectedLang = 'all';
        let currentWikisource = WIKISOURCES[0];
        
        // Fonction pour changer la langue
        function changeLanguage(lang) {
            selectedLang = lang;
            localStorage.setItem('palimpseste_lang', lang);
            toast(lang === 'all' ? '🌍 Toutes les langues activées' : `🌐 Langue: ${WIKISOURCES.find(w => w.lang === lang)?.name || lang}`);
            // Recharger le feed avec la nouvelle langue
            shuffleFeed();
        }
        
        // Récupérer les Wikisources selon le filtre de langue
        function getActiveWikisources() {
            if (selectedLang === 'all') return WIKISOURCES;
            return WIKISOURCES.filter(w => w.lang === selectedLang);
        }
        
        const GENRE_COLORS = {
            'poésie': '#bf5af2', 'poetry': '#bf5af2', 'Gedicht': '#bf5af2', 'poesia': '#bf5af2', 'poema': '#bf5af2',
            'fable': '#30d158', 'Fabel': '#30d158', 'favola': '#30d158', 'fábula': '#30d158',
            'conte': '#ff9f0a', 'tale': '#ff9f0a', 'Märchen': '#ff9f0a', 'racconto': '#ff9f0a', 'cuento': '#ff9f0a',
            'nouvelle': '#ff453a', 'story': '#ff453a', 'Novelle': '#ff453a', 'novella': '#ff453a',
            'théâtre': '#64d2ff', 'drama': '#64d2ff', 'theater': '#64d2ff', 'teatro': '#64d2ff',
            'texte': '#6e6e73', 'text': '#6e6e73',
            'mystique': '#ffd60a', 'mystic': '#ffd60a',
            'philosophie': '#ac8e68', 'philosophy': '#ac8e68',
            'roman': '#ff6482', 'novel': '#ff6482', 'Roman': '#ff6482', 'romanzo': '#ff6482'
        };
        
        // Graphe dynamique des connexions (enrichi au fur et à mesure)
        let authorConnections = {};

        let state = {
            likes: new Set(), readCount: 0, loading: false, cache: new Map(),
            textPool: [], shownPages: new Set(), cardIdx: 0,
            authorStats: {}, genreStats: {},
            likedAuthors: new Set(), discoveredConnections: new Set(),
            achievements: [], readingPath: [],
            // Statistiques de lecture
            readingStats: {
                totalWordsRead: 0,
                totalReadingTime: 0, // en secondes
                streak: 0,
                lastReadDate: null,
                sessionsToday: 0,
                bestStreak: 0,
                dailyWords: {} // { 'YYYY-MM-DD': wordsCount }
            }
        };
        
        // Timer de lecture
        let readingTimer = null;
        let sessionStartTime = null;


        // Recherche via l'API - supporte plusieurs Wikisources
        async function searchTexts(query, limit = 20, wikisource = currentWikisource) {
            const url = `${wikisource.url}/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=${limit}&srnamespace=0&format=json&origin=*`;

            try {
                const res = await fetch(url);
                const data = await res.json();
                const results = (data.query?.search || []).map(r => ({ ...r, lang: wikisource.lang, wikisource }));

                return results;
            } catch (e) { 
                console.error('searchTexts error:', e);
                return []; 
            }
        }
        
        // Récupère le texte avec gestion intelligente (multilingue)
        async function fetchText(page, depth = 0, wikisource = currentWikisource) {
            if (depth > 4) {

                return null;
            }
            
            // Filtrage précoce des pages indésirables
            if (!isValidTitle(page)) {

                return null;
            }
            
            const cacheKey = `${wikisource.lang}:${page}`;
            if (state.cache.has(cacheKey)) return state.cache.get(cacheKey);

            // Requête enrichie : texte + catégories + liens pour analyse du graphe
            const url = `${wikisource.url}/w/api.php?action=parse&page=${encodeURIComponent(page)}&prop=text|displaytitle|categories|links&pllimit=500&format=json&origin=*&redirects=true`;
            
            try {
                const res = await fetch(url);
                const data = await res.json();
                if (data.error) return null;
                
                if (data.parse?.text) {
                    // Vérifier le displaytitle aussi
                    const displayTitle = data.parse.displaytitle || '';
                    if (!isValidTitle(displayTitle)) return null;
                    
                    const html = data.parse.text['*'];
                    const links = data.parse.links || [];
                    
                    // ═══ ANALYSE DU GRAPHE DES LIENS ═══
                    // Compter les liens vers des sous-pages (même préfixe + "/")
                    const basePage = page.split('/')[0];
                    const subPageLinks = links.filter(l => {
                        const title = l['*'] || '';
                        return title.startsWith(basePage + '/') && l.ns === 0;
                    });
                    
                    // Si la page a beaucoup de liens vers ses sous-pages, c'est un sommaire
                    const isLikelySommaire = subPageLinks.length >= 5;
                    
                    if (isLikelySommaire && subPageLinks.length > 0) {
                        // Choisir une sous-page au hasard et la suivre
                        const randomSub = subPageLinks[Math.floor(Math.random() * subPageLinks.length)];

                        return await fetchText(randomSub['*'], depth + 1, wikisource);
                    }
                    
                    const analysis = analyzeHtml(html);
                    
                    // Si page d'index classique (redirections, éditions multiples)
                    if (analysis.isIndex && analysis.subLink) {
                        return await fetchText(analysis.subLink, depth + 1, wikisource);
                    }
                    
                    // ═══ ANALYSE STATISTIQUE DE QUALITÉ ═══
                    // Filtrage des "faux textes" (pages de garde, listes, etc.)
                    const quality = analyzeContentQuality(analysis.text, links, page);
                    if (!quality.isGood) {

                         // Si c'est rejeté parce que c'est un sommaire/liste, on essaie de trouver un lien pertinent
                         if (quality.reason === 'link_density' || quality.reason === 'listy') {
                             const contentLinks = links.filter(l => l.ns === 0 && !l['*'].includes(':'));
                             if (contentLinks.length > 0) {
                                 const randomLink = contentLinks[Math.floor(Math.random() * contentLinks.length)];
                                 return await fetchText(randomLink['*'], depth + 1, wikisource);
                             }
                         }
                         return null;
                    }

                    if (analysis.text && analysis.text.length > 150) {
                        // Nettoyer le titre (supprimer HTML et spans)
                        let cleanTitle = (data.parse.displaytitle || page)
                            .replace(/<[^>]+>/g, '')  // Supprimer tout HTML
                            .replace(/&nbsp;/g, ' ')
                            .replace(/&amp;/g, '&')
                            .replace(/&lt;/g, '<')
                            .replace(/&gt;/g, '>')
                            .replace(/mw-page-title[^\s]*/gi, '')  // Supprimer classes MW résiduelles
                            .trim();
                        
                        // Double vérification du titre nettoyé
                        if (!isValidTitle(cleanTitle)) return null;
                        
                        // ===== DÉTECTION AUTEUR (multilingue) =====
                        let detectedAuthor = null;
                        
                        // 1. Chercher dans les liens de la page (liens "Auteur:XXX" / "Author:XXX" / etc.)
                        const authorPrefixes = ['Auteur:', 'Author:', 'Autor:', 'Autore:', '作者:'];
                        const links = data.parse.links || [];
                        for (const link of links) {
                            const linkTitle = link['*'] || '';
                            for (const prefix of authorPrefixes) {
                                if (linkTitle.startsWith(prefix)) {
                                    const authorName = linkTitle.replace(prefix, '').trim();
                                    if (authorName.length > 2 && authorName.length < 50) {
                                        detectedAuthor = authorName;
                                        break;
                                    }
                                }
                            }
                            if (detectedAuthor) break;
                        }
                        
                        // 2. Chercher dans les catégories (patterns multilingues)
                        if (!detectedAuthor) {
                            const categories = data.parse.categories || [];
                            for (const cat of categories) {
                                const catName = cat['*'] || '';
                                // Patterns multilingues
                                const authorMatch = catName.match(/(?:Textes|Poèmes|Œuvres|Works|Texts|Poems|Werke|Opere|Obras)\s+(?:de|by|von|di)\s+(.+)/i);
                                if (authorMatch && authorMatch[1].length > 2) {
                                    detectedAuthor = authorMatch[1].trim();
                                    break;
                                }
                            }
                        }
                        
                        // 3. Chercher un lien Auteur: dans le HTML
                        if (!detectedAuthor) {
                            detectedAuthor = analysis.authorFromHtml;
                        }
                        
                        const result = { 
                            text: analysis.text, 
                            title: cleanTitle,
                            author: detectedAuthor,
                            lang: wikisource.lang,
                            wikisource: wikisource
                        };
                        state.cache.set(cacheKey, result);
                        return result;
                    }
                }
                return null;
            } catch (e) { return null; }
        }

        function analyzeHtml(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            
            // ===== EXTRAIRE L'AUTEUR DEPUIS LE HTML =====
            let authorFromHtml = null;
            
            // 1. Chercher les liens "Auteur:XXX" dans le HTML
            const authorLinks = div.querySelectorAll('a[href*="Auteur:"]');
            for (const a of authorLinks) {
                const href = a.getAttribute('href') || '';
                const match = href.match(/Auteur:([^"&?#]+)/);
                if (match) {
                    authorFromHtml = decodeURIComponent(match[1]).replace(/_/g, ' ').trim();
                    break;
                }
            }
            
            // 2. Chercher dans les éléments de header/metadata Wikisource
            if (!authorFromHtml) {
                const headerAuthor = div.querySelector('.ws-author, .author, .auteur, [class*="auteur"]');
                if (headerAuthor) {
                    const authorText = headerAuthor.textContent.trim();
                    if (authorText.length > 2 && authorText.length < 50) {
                        authorFromHtml = authorText;
                    }
                }
            }
            
            // 3. Chercher le pattern "par XXX" ou "de XXX" en début de page
            if (!authorFromHtml) {
                const firstLines = div.textContent.substring(0, 500);
                const parMatch = firstLines.match(/(?:^|\n)\s*(?:par|de)\s+([A-ZÀ-Ü][a-zà-ü]+(?:\s+(?:de\s+)?[A-ZÀ-Ü][a-zà-ü\-]+){0,3})\s*(?:\n|$)/m);
                if (parMatch && parMatch[1].length > 3 && parMatch[1].length < 40) {
                    authorFromHtml = parMatch[1].trim();
                }
            }
            
            // Supprimer tous les spans avec page-title AVANT toute analyse
            div.querySelectorAll('span[class*="page-title"], .mw-page-title-main, .mw-page-title').forEach(el => el.remove());
            
            // Détecter page d'index/sommaire (simplifié - seulement les cas évidents)
            const isRedirect = !!div.querySelector('.redirectMsg');
            const txt = div.textContent;
            const hasEditions = txt.includes('propose plusieurs éditions') || 
                               txt.includes('Cette page répertorie');
            
            // Seulement les redirections et pages d'éditions multiples sont des index
            const isIndex = isRedirect || hasEditions;
            
            // Trouver un sous-lien utile si c'est un index
            let subLink = null;
            if (isIndex) {
                const links = div.querySelectorAll('a[href^="/wiki/"]');
                for (const a of links) {
                    const href = a.getAttribute('href');
                    if (href && !href.includes(':') && !href.includes('Auteur') && !href.includes('Discussion')) {
                        const name = decodeURIComponent(href.replace('/wiki/', ''));
                        // Chercher des pages qui ressemblent à du contenu réel
                        if (name.includes('/') && !name.endsWith('/')) {
                            // Éviter les pages de métadonnées
                            if (!name.includes('Préface') && !name.includes('Notice') && 
                                !name.includes('Table') && !name.includes('Index')) {
                                subLink = name;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Nettoyer - supprimer tous les éléments non désirés
            div.querySelectorAll('.ws-noexport, .noprint, .mw-editsection, script, style, .reference, .toc, .navbox, .infobox, .metadata, .hatnote, .ambox, .catlinks, .mw-headline, .redirectMsg, .homonymie, .bandeau-homonymie, .bandeau-portail, .headertemplate, .ws-header, .mw-page-title-main, .mw-page-title, span[class*="page-title"], .titreoeuvre, .auteur-oeuvre, .header').forEach(el => el.remove());
            
            let content = div.querySelector('.prp-pages-output, .poem') || div.querySelector('.mw-parser-output') || div;
            
            // Supprimer TOUS les spans de MediaWiki
            content.querySelectorAll('span').forEach(el => {
                const cls = el.className || '';
                if (cls.includes('page-title') || cls.includes('mw-') || cls.includes('ws-')) {
                    el.remove();
                }
            });
            
            let text = content.innerText || content.textContent;
            
            // Nettoyer les résidus HTML et MediaWiki
            text = text.replace(/\[modifier[^\]]*\]/g, '').replace(/\[\d+\]/g, '')
                       .replace(/modifier le wikicode/gi, '').replace(/\n{3,}/g, '\n\n')
                       .replace(/<span[^>]*>|<\/span>/gi, '')  // Supprimer spans résiduels
                       .replace(/<[^>]+>/g, '')  // Supprimer tout HTML résiduel
                       .replace(/mw-page-title[^\s]*/gi, '')  // Supprimer classes MW
                       .replace(/&nbsp;/g, ' ').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>')
                       .replace(/Poésies \([^)]+\)/g, '')  // Supprimer titres de recueils parasites
                       .trim();
            
            // Enlever métadonnées, préfaces, mentions de conférence en début
            const lines = text.split('\n');
            let start = 0;
            for (let i = 0; i < Math.min(15, lines.length); i++) {
                const l = lines[i].toLowerCase();
                const line = lines[i].trim();
                if (l.includes('sommaire') || l.includes('édition') || l.includes('navigation') || 
                    l.includes('conférence') || l.includes('présenté') || l.includes('siège') ||
                    l.includes('présidée par') || l.includes('professeur') || l.includes('faculté') ||
                    l.includes('mw-page-title') || l.includes('span class') ||
                    line.length < 3 || (line.startsWith('(') && line.endsWith(')'))) {
                    start = i + 1;
                } else if (line.length > 40) break;
            }
            text = lines.slice(start).join('\n').trim();
            
            if (text.length > 5000) {
                text = text.substring(0, 5000);
                const cut = Math.max(text.lastIndexOf('\n\n'), text.lastIndexOf('. '));
                if (cut > 4000) text = text.substring(0, cut + 1);
                text += '\n\n[...]';
            }
            
            // ═══ DÉTECTION ROBUSTE DES SCORIES ═══
            if (isLikelyJunk(text)) {
                return { text: '', isIndex: true, subLink, authorFromHtml };
            }
            
            return { text, isIndex, subLink, authorFromHtml };
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🛡️ FILTRE MINIMAL - On laisse le graphe des liens faire le travail
        // ═══════════════════════════════════════════════════════════
        function isLikelyJunk(text) {
            // Filtre minimal : juste vérifier qu'il y a du contenu
            if (!text || text.length < 100) return true;
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            if (lines.length < 2) return true;
            return false;
        }

        // ═══════════════════════════════════════════════════════════
        // 🕸️ EXPLORATION PAR ARBORESCENCE (Catégories)
        // ═══════════════════════════════════════════════════════════
        
        let currentCategoryPath = [];
        let currentBrowseMode = null; // 'category' ou 'search'
        
        // Branches enrichies par genre (auteurs majeurs + courants)
        const GENRE_BRANCHES = {
            'philosophie': {
                'Courants': ['Rationalisme', 'Empirisme', 'Idéalisme', 'Existentialisme', 'Stoïcisme', 'Épicurisme', 'Scepticisme', 'Phénoménologie'],
                'Domaines': ['Métaphysique', 'Éthique', 'Épistémologie', 'Logique', 'Esthétique', 'Philosophie politique', 'Ontologie'],
                'Antiquité': ['Platon', 'Aristote', 'Épictète', 'Marc Aurèle', 'Sénèque', 'Cicéron', 'Lucrèce'],
                'XVIIe siècle': ['Descartes', 'Pascal', 'Spinoza', 'Leibniz', 'Malebranche', 'Hobbes', 'Locke'],
                'XVIIIe siècle': ['Voltaire', 'Rousseau', 'Montesquieu', 'Diderot', 'Hume', 'Kant', 'Condillac'],
                'XIXe siècle': ['Hegel', 'Schopenhauer', 'Nietzsche', 'Kierkegaard', 'Comte', 'Marx', 'Bergson']
            },
            'poésie': {
                'Formes': ['Sonnet', 'Ode', 'Élégie', 'Ballade', 'Fable', 'Épopée', 'Haïku'],
                'Mouvements': ['Romantisme', 'Parnasse', 'Symbolisme', 'Surréalisme', 'Baroque'],
                'XVIe siècle': ['Ronsard', 'Du Bellay', 'Louise Labé', 'Marot'],
                'XVIIe siècle': ['La Fontaine', 'Malherbe', 'Boileau', 'Racine'],
                'XIXe siècle': ['Hugo', 'Baudelaire', 'Verlaine', 'Rimbaud', 'Mallarmé', 'Lamartine', 'Musset', 'Nerval'],
                'XXe siècle': ['Apollinaire', 'Éluard', 'Aragon', 'Prévert', 'Char', 'Valéry']
            },
            'roman': {
                'Genres': ['Roman épistolaire', 'Roman historique', 'Roman réaliste', 'Roman naturaliste', 'Roman psychologique'],
                'XVIIe siècle': ['Madame de La Fayette', 'Scarron', 'Fénelon'],
                'XVIIIe siècle': ['Voltaire', 'Rousseau', 'Diderot', 'Laclos', 'Prévost', 'Bernardin de Saint-Pierre'],
                'XIXe siècle': ['Balzac', 'Stendhal', 'Flaubert', 'Zola', 'Maupassant', 'Hugo', 'Dumas', 'Sand'],
                'XXe siècle': ['Proust', 'Gide', 'Céline', 'Camus', 'Sartre', 'Colette']
            },
            'théâtre': {
                'Genres': ['Tragédie', 'Comédie', 'Drame', 'Farce', 'Vaudeville'],
                'Antiquité': ['Sophocle', 'Euripide', 'Eschyle', 'Aristophane', 'Plaute', 'Térence'],
                'XVIIe siècle': ['Molière', 'Racine', 'Corneille', 'Marivaux'],
                'XVIIIe siècle': ['Beaumarchais', 'Voltaire', 'Marivaux'],
                'XIXe siècle': ['Hugo', 'Musset', 'Rostand', 'Labiche'],
                'XXe siècle': ['Claudel', 'Giraudoux', 'Anouilh', 'Ionesco', 'Beckett']
            },
            'conte': {
                'Types': ['Conte merveilleux', 'Conte philosophique', 'Conte moral', 'Conte fantastique'],
                'Auteurs': ['Perrault', 'Grimm', 'Andersen', 'Voltaire', 'Maupassant', 'Hoffmann']
            },
            'nouvelle': {
                'Styles': ['Nouvelle réaliste', 'Nouvelle fantastique', 'Nouvelle psychologique'],
                'Auteurs': ['Maupassant', 'Mérimée', 'Balzac', 'Flaubert', 'Zola', 'Villiers de l\'Isle-Adam']
            },
            'mystique': {
                'Traditions': ['Mystique chrétienne', 'Mystique soufie', 'Kabbale'],
                'Auteurs': ['Thérèse d\'Avila', 'Jean de la Croix', 'Maître Eckhart', 'François de Sales', 'Fénelon', 'Bossuet']
            },
            'fable': {
                'Auteurs': ['La Fontaine', 'Ésope', 'Phèdre', 'Florian']
            },
            'histoire': {
                'Périodes': ['Antiquité', 'Moyen Âge', 'Renaissance', 'Révolution française', 'XIXe siècle'],
                'Historiens': ['Hérodote', 'Thucydide', 'Tacite', 'Michelet', 'Tocqueville', 'Voltaire']
            }
        };
        
        // Mappage des genres simples vers les catégories racines Wikisource
        const CATEGORY_ROOTS = {
            fr: {
                'poésie': 'Catégorie:Poésie',
                'roman': 'Catégorie:Romans',
                'théâtre': 'Catégorie:Théâtre',
                'philosophie': 'Catégorie:Philosophie',
                'conte': 'Catégorie:Contes',
                'fable': 'Catégorie:Fables',
                'nouvelle': 'Catégorie:Nouvelles',
                'essai': 'Catégorie:Essais',
                'histoire': 'Catégorie:Histoire',
                'lettres': 'Catégorie:Correspondances',
                'mystique': 'Catégorie:Textes_spirituels'
            },
            en: {
                'poetry': 'Category:Poetry',
                'novel': 'Category:Novels',
                'drama': 'Category:Plays',
                'philosophy': 'Category:Philosophy',
                'tale': 'Category:Tales',
                'history': 'Category:History',
                'essay': 'Category:Essays'
            },
            de: {
                'Gedicht': 'Kategorie:Gedicht_Titel',
                'Roman': 'Kategorie:Roman',
                'Märchen': 'Kategorie:Märchen'
            }
        };

        async function exploreCategory(genreOrCategoryName, isSubCat = false) {
            const wikisource = currentWikisource;
            const lang = wikisource.lang;
            const genreLower = genreOrCategoryName.toLowerCase();
            
            // Afficher l'UI
            document.getElementById('categoryNav').style.display = 'block';
            document.getElementById('catSubcategories').innerHTML = '<div style="color:var(--muted)">Chargement...</div>';
            document.getElementById('feed').innerHTML = '';
            state.textPool = [];
            
            // Cas 1: C'est un genre racine avec branches enrichies
            if (!isSubCat && GENRE_BRANCHES[genreLower]) {
                currentCategoryPath = [genreOrCategoryName];
                currentBrowseMode = 'branches';
                renderBreadcrumbs();
                renderEnrichedBranches(genreLower);
                return;
            }
            
            // Cas 2: C'est une branche (recherche par terme)
            if (!isSubCat) {
                currentCategoryPath = [genreOrCategoryName];
            } else if (!currentCategoryPath.includes(genreOrCategoryName)) {
                currentCategoryPath.push(genreOrCategoryName);
            } else {
                const index = currentCategoryPath.indexOf(genreOrCategoryName);
                currentCategoryPath = currentCategoryPath.slice(0, index + 1);
            }
            
            renderBreadcrumbs();
            currentBrowseMode = 'search';
            
            // Rechercher sur Wikisource
            await searchByTerm(genreOrCategoryName, wikisource);
        }
        
        // Affiche les branches enrichies pour un genre
        function renderEnrichedBranches(genre) {
            const branches = GENRE_BRANCHES[genre];
            if (!branches) return;
            
            const container = document.getElementById('catSubcategories');
            let html = '<div class="branches-container">';
            
            for (const [groupName, items] of Object.entries(branches)) {
                html += `<div class="branch-group">
                    <div class="branch-group-title">${groupName}</div>
                    <div class="branch-items">
                        ${items.map(item => `<div class="cat-pill" onclick="exploreCategory('${item.replace(/'/g, "\\'")}', true)">${item}</div>`).join('')}
                    </div>
                </div>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
            
            // Message d'info
            document.getElementById('feed').innerHTML = '<div class="empty-state">👆 Choisissez une branche ci-dessus pour explorer les textes</div>';
        }
        
        // Recherche par terme (auteur, courant, etc.)
        async function searchByTerm(term, wikisource) {
            document.getElementById('catSubcategories').innerHTML = `<div style="color:var(--muted)">🔍 Recherche "${term}"...</div>`;
            
            try {
                // Recherche élargie sur Wikisource
                const results = await searchTexts(term, 50, wikisource);
                
                // Filtrer les résultats valides
                const validResults = results.filter(r => isValidTitle(r.title) && r.snippet?.length > 20);
                
                // Info sur les résultats
                const container = document.getElementById('catSubcategories');
                if (validResults.length > 0) {
                    container.innerHTML = `<div style="font-size:0.8rem; color:var(--accent);">📚 ${validResults.length} texte${validResults.length > 1 ? 's' : ''} trouvé${validResults.length > 1 ? 's' : ''} pour "${term}"</div>`;
                } else {
                    container.innerHTML = `<div style="font-size:0.8rem; color:var(--muted);">Aucun résultat pour "${term}"</div>`;
                }
                
                // Remplir le pool
                state.textPool = validResults.map(r => ({
                    title: r.title,
                    snippet: r.snippet,
                    lang: wikisource.lang,
                    wikisource: wikisource,
                    source: 'search_exploration'
                }));
                
                // Mélanger et charger
                state.textPool = state.textPool.sort(() => Math.random() - 0.5);
                
                if (state.textPool.length > 0) {
                    loadMore();
                } else {
                    document.getElementById('feed').innerHTML = `<div class="empty-state">Aucun texte trouvé pour "${term}".<br>Essayez un autre terme.</div>`;
                }
                
            } catch (e) {
                console.error('Search error:', e);
                document.getElementById('catSubcategories').innerHTML = '<div style="color:var(--accent)">Erreur de recherche</div>';
            }
        }
        
        async function fetchCategoryData(categoryName, wikisource) {
            // Récupérer sous-catégories et pages
            const url = `${wikisource.url}/w/api.php?action=query&list=categorymembers&cmtitle=${encodeURIComponent(categoryName)}&cmlimit=100&format=json&origin=*`;
            
            try {
                const res = await fetch(url);
                const data = await res.json();
                const members = data.query?.categorymembers || [];
                
                const subcats = members.filter(m => m.ns === 14); // 14 = Category
                const pages = members.filter(m => m.ns === 0);    // 0 = Page
                
                renderSubcategories(subcats, pages.length);
                
                // Remplir le pool avec les pages trouvées
                state.textPool = []; // Reset pour cette catégorie
                for (const p of pages) {
                    if (isValidTitle(p.title)) {
                         state.textPool.push({
                             title: p.title,
                             lang: wikisource.lang,
                             wikisource: wikisource,
                             source: 'category_exploration'
                         });
                    }
                }
                

                
                // Mélanger et charger
                state.textPool = state.textPool.sort(() => Math.random() - 0.5);
                
                if (state.textPool.length > 0) {
                    loadMore();
                } else if (subcats.length === 0) {
                    document.getElementById('feed').innerHTML = '<div class="empty-state">Aucun texte direct dans cette catégorie.<br>Essayez une autre branche.</div>';
                }
                
            } catch (e) {
                console.error('Category error:', e);
                document.getElementById('catSubcategories').innerHTML = '<div style="color:var(--accent)">Erreur de chargement</div>';
            }
        }
        
        function renderBreadcrumbs() {
            const container = document.getElementById('catBreadcrumbs');
            container.innerHTML = currentCategoryPath.map((cat, idx) => {
                const name = cat.split(':')[1] || cat;
                const isLast = idx === currentCategoryPath.length - 1;
                return `
                    <span class="cat-crumb ${isLast ? 'active' : ''}" onclick="exploreCategory('${cat.replace(/'/g, "\\'")}', true)">${name}</span>
                    ${!isLast ? '<span class="cat-sep">></span>' : ''}
                `;
            }).join('');
        }
        
        function renderSubcategories(subcats, pageCount = 0) {
            const container = document.getElementById('catSubcategories');
            
            let html = '';
            
            // Info sur les pages directes
            if (pageCount > 0) {
                html += `<div style="font-size:0.8rem; color:var(--accent); margin-bottom:0.5rem;">📚 ${pageCount} texte${pageCount > 1 ? 's' : ''} dans cette catégorie</div>`;
            }
            
            if (subcats.length === 0) {
                if (pageCount === 0) {
                    html += '<div style="font-size:0.8rem; color:var(--muted); font-style:italic;">Catégorie vide ou sous-pages uniquement</div>';
                }
                container.innerHTML = html;
                return;
            }
            
            html += `<div style="font-size:0.75rem; color:var(--muted); margin-bottom:0.3rem;">↳ ${subcats.length} sous-catégorie${subcats.length > 1 ? 's' : ''} :</div>`;
            html += subcats.map(c => {
                const name = (c.title.split(':')[1] || c.title).replace(/_/g, ' ');
                return `<div class="cat-pill" onclick="exploreCategory('${c.title.replace(/'/g, "\\'")}', true)">${name}</div>`;
            }).join('');
            
            container.innerHTML = html;
        }
        
        function closeCategoryMode() {
            document.getElementById('categoryNav').style.display = 'none';
            currentCategoryPath = [];
            shuffleFeed(); // Revenir au mode normal
        }

        // ═══════════════════════════════════════════════════════════
        // � PROJECT GUTENBERG - Classiques du domaine public
        // ═══════════════════════════════════════════════════════════
        async function fetchGutenberg() {
            const works = ALT_SOURCES.gutenberg.works;
            // Filtrer par langue si nécessaire
            const filtered = selectedLang === 'all' 
                ? works 
                : works.filter(w => w.lang === selectedLang);
            
            if (filtered.length === 0) return [];
            
            // Choisir une œuvre au hasard
            const work = filtered[Math.floor(Math.random() * filtered.length)];
            const cacheKey = `gutenberg:${work.id}`;
            
            // Éviter les doublons
            if (state.shownPages.has(cacheKey)) return [];
            
            try {
                // Utiliser l'API de téléchargement texte de Gutenberg
                const res = await fetch(`https://www.gutenberg.org/files/${work.id}/${work.id}-0.txt`, {
                    mode: 'cors'
                }).catch(() => 
                    // Fallback sur un autre format
                    fetch(`https://www.gutenberg.org/cache/epub/${work.id}/pg${work.id}.txt`)
                );
                
                if (!res.ok) throw new Error('Gutenberg fetch failed');
                
                let text = await res.text();
                
                // Nettoyer le texte Gutenberg (retirer header/footer légaux)
                const startMarkers = ['*** START OF', '***START OF', 'START OF THE PROJECT'];
                const endMarkers = ['*** END OF', '***END OF', 'END OF THE PROJECT', 'End of Project'];
                
                for (const marker of startMarkers) {
                    const idx = text.indexOf(marker);
                    if (idx !== -1) {
                        const nextLine = text.indexOf('\n', idx);
                        text = text.substring(nextLine + 1);
                        break;
                    }
                }
                
                for (const marker of endMarkers) {
                    const idx = text.indexOf(marker);
                    if (idx !== -1) {
                        text = text.substring(0, idx);
                        break;
                    }
                }
                
                // Prendre un extrait aléatoire (pas tout le livre!)
                const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 100);
                if (paragraphs.length > 10) {
                    // Choisir un passage au hasard (pas le début)
                    const startIdx = Math.floor(Math.random() * Math.max(1, paragraphs.length - 10)) + 5;
                    const excerpt = paragraphs.slice(startIdx, startIdx + 5).join('\n\n');
                    

                    
                    return [{
                        title: work.title,
                        text: excerpt.trim(),
                        author: work.author,
                        source: 'gutenberg',
                        lang: work.lang,
                        gutenbergId: work.id
                    }];
                }
            } catch (e) {
                console.error('Gutenberg error:', work.title, e);
            }
            return [];
        }

        // ═══════════════════════════════════════════════════════════
        // �📜 POETRYDB - Poésie anglaise de qualité (pas de scories!)
        // ═══════════════════════════════════════════════════════════
        async function fetchPoetryDB() {
            const authors = ALT_SOURCES.poetrydb.authors;
            const randomAuthor = authors[Math.floor(Math.random() * authors.length)];
            
            try {
                const res = await fetch(`https://poetrydb.org/author/${encodeURIComponent(randomAuthor)}/title,author,lines`);
                const poems = await res.json();
                
                if (Array.isArray(poems) && poems.length > 0) {
                    // Prendre quelques poèmes au hasard
                    const shuffled = poems.sort(() => Math.random() - 0.5).slice(0, 5);

                    
                    return shuffled.map(poem => ({
                        title: poem.title,
                        text: poem.lines.join('\n'),
                        author: poem.author,
                        source: 'poetrydb',
                        lang: 'en'
                    }));
                }
            } catch (e) {
                console.error('PoetryDB error:', e);
            }
            return [];
        }

        // ═══════════════════════════════════════════════════════════
        // 🌍 ALIMENTER LE POOL - Littérature mondiale
        // ═══════════════════════════════════════════════════════════
        async function fillPool() {
            // === 1. POETRYDB (si anglais actif) - Qualité garantie ===
            if (selectedLang === 'all' || selectedLang === 'en') {
                try {
                    const poems = await fetchPoetryDB();
                    for (const poem of poems) {
                        if (!state.shownPages.has('poetrydb:' + poem.title)) {
                            // Ajouter EN PRIORITÉ (pas de scories!)
                            state.textPool.unshift({
                                title: poem.title,
                                text: poem.text,
                                author: poem.author,
                                lang: 'en',
                                source: 'poetrydb',
                                isPreloaded: true // Texte déjà chargé
                            });
                        }
                    }
                } catch (e) {
                    console.error('PoetryDB fillPool error:', e);
                }
            }
            
            // === 1.5 PROJECT GUTENBERG - Classiques du domaine public ===
            try {
                const gutenbergTexts = await fetchGutenberg();
                for (const item of gutenbergTexts) {
                    state.textPool.unshift({
                        ...item,
                        isPreloaded: true
                    });
                }
            } catch (e) {
                console.error('Gutenberg fillPool error:', e);
            }
            
            // === 2. WIKISOURCE (sources traditionnelles) ===
            const activeSources = getActiveWikisources();
            if (activeSources.length === 0 && state.textPool.length === 0) {
                console.error('Aucune source active');
                return;
            }
            const shuffledSources = [...activeSources].sort(() => Math.random() - 0.5).slice(0, Math.min(3, activeSources.length));
            

            
            for (const ws of shuffledSources) {
                const terms = [...(SEARCH_TERMS[ws.lang] || SEARCH_TERMS.en)];
                const selectedTerms = terms.sort(() => Math.random() - 0.5).slice(0, 5);
                
                for (const term of selectedTerms) {
                    try {
                        const results = await searchTexts(term, 15, ws);
                        for (const r of results) {
                            if (!state.shownPages.has(r.title) && !state.textPool.some(t => t.title === r.title)) {
                                // Filtrage généraliste par structure du titre
                                if (isValidTitle(r.title) && r.snippet?.length > 20) {
                                    // Prioriser les sous-pages (contenu réel)
                                    const item = { 
                                        title: r.title, 
                                        snippet: r.snippet, 
                                        lang: ws.lang,
                                        wikisource: ws 
                                    };
                                    if (r.title.includes('/')) {
                                        state.textPool.unshift(item);
                                    } else {
                                        state.textPool.push(item);
                                    }
                                }
                            }
                        }
                    } catch (e) { 
                        console.error('fillPool error:', e);
                    }
                }
            }
            state.textPool = [...state.textPool].sort(() => Math.random() - 0.5);
        }
        
        // Filtrage généraliste du titre (exclut les pages non littéraires)
        function isValidTitle(title) {
            if (!title || title.length < 3) return false;
            const t = title.toLowerCase();
            
            // Exclure les namespaces spéciaux (universel)
            if (t.includes('category:') || t.includes('catégorie:') || 
                t.includes('kategorie:') || t.includes('categoria:')) return false;
            
            // Liste étendue des namespaces wiki
            if (/^(help|aide|hilfe|aiuto|ayuda|ajuda|manual|project|projet|image|file|fichier|template|modèle|module|media|special|spécial):/i.test(t)) return false;

            if (t.includes('author:') || t.includes('auteur:') || 
                t.includes('autor:') || t.includes('autore:')) return false;
            if (t.includes('talk:') || t.includes('discussion:') || 
                t.includes('diskussion:') || t.includes('discussione:')) return false;
            if (t.includes('index:') || t.includes('page:') || t.includes('file:')) return false;
            
            // Exclure les listes (pattern universel)
            if (/^list[ea]?\s+(de|of|di|von)/i.test(t)) return false;
            if (t.startsWith('index ') || t.endsWith(' index')) return false;
            if (t.includes('table des matières') || t.includes('table of contents') || t.includes('inhaltsverzeichnis')) return false;
            if (t.includes('bibliographie') || t.includes('bibliography')) return false;
            
            // Exclure les études biographiques et critiques (souvent des pages de garde)
            if (t.includes('sa vie et son œuvre') || t.includes('sa vie et son oeuvre')) return false;
            if (t.includes('his life and work') || t.includes('sein leben')) return false;
            if (t.includes('étude biographique') || t.includes('étude sur')) return false;
            if (t.includes('biographical study') || t.includes('biography of')) return false;
            if (/\bbiograph/i.test(t) && !t.includes('/')) return false;
            
            // Exclure les œuvres complètes sans sous-page (ce sont des sommaires)
            if ((t.includes('œuvres complètes') || t.includes('complete works') || 
                 t.includes('gesammelte werke') || t.includes('opere complete')) && !t.includes('/')) return false;
            
            return true;
        }

        // ═══════════════════════════════════════════════════════════
        // 🕵️ ANALYSE DE QUALITÉ DU CONTENU (Heuristiques)
        // ═══════════════════════════════════════════════════════════
        function analyzeContentQuality(text, links, title) {
            if (!text) return { isGood: false, reason: 'empty' };
            const len = text.length;
            
            // 1. Trop court = Fragment ou erreur
            if (len < 300) return { isGood: false, reason: 'too_short' };
            
            // 2. Trop long = Livre entier non découpé (mauvaise UX)
            if (len > 80000) return { isGood: false, reason: 'too_long' };
            
            // 3. Densité de liens (Link Density)
            // Si une page est composée à 20% de liens, c'est un sommaire/hub
            // On estime ~30 chars par lien en moyenne (titre + balise)
            const linkCharsEstimate = links.length * 30;
            const linkDensity = linkCharsEstimate / len;
            
            // Seuil : > 25% de liens = Sommaire
            if (linkDensity > 0.25) return { isGood: false, reason: 'link_density' };
            
            // 4. Structure "Paragraphe" vs "Liste"
            // Un vrai texte a des phrases qui finissent par des points.
            // Une liste a des retours à la ligne fréquents sans ponctuation.
            const lines = text.split('\n').filter(l => l.trim().length > 0);
            const avgLineLength = len / Math.max(1, lines.length);
            
            // Si lignes très courtes (< 50 chars) ET pas de ponctuation finale
            if (avgLineLength < 60) {
                // Exception pour la poésie : lignes courtes mais strophes
                // Vérifier la ponctuation
                const linesEndingWithPunctuation = lines.filter(l => /[.!?…:;]$/.test(l.trim())).length;
                const punctuationRatio = linesEndingWithPunctuation / lines.length;
                
                // Si peu de ponctuation finale (< 30%), c'est une liste brute
                if (punctuationRatio < 0.3) return { isGood: false, reason: 'listy' };
            }
            
            // 5. Structure Words (Meta-titres)
            const t = title.toLowerCase();
            const badWords = ['sommaire', 'contents', 'inhalt', 'table', 'index', 'chapitres', 'chapters'];
            if (badWords.some(w => t.includes(w))) return { isGood: false, reason: 'title_blacklist' };

            return { isGood: true };
        }

        // Normalise un nom d'auteur (simplifié - accepte tout nom valide)
        function normalizeAuthor(rawAuthor) {
            if (!rawAuthor) return null;
            // Nettoyer le nom
            let clean = rawAuthor
                .replace(/_/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            
            // Vérifier que c'est un nom valide (commence par majuscule, longueur raisonnable)
            if (clean.length > 2 && clean.length < 60 && /^[A-ZÀ-ÜА-Яぁ-んァ-ン一-龯\u0600-\u06FF]/.test(clean)) {
                return clean;
            }
            return null;
        }

        function detectAuthor(title, text, metadataAuthor = null) {
            // 1. PRIORITÉ : Auteur des métadonnées Wikisource (liens, catégories)
            if (metadataAuthor) {
                const normalized = normalizeAuthor(metadataAuthor);
                if (normalized) return normalized;
            }
            
            // 2. Chercher dans le titre (format "Œuvre (Auteur)")
            const parenthMatch = title.match(/\(([^)]+)\)$/);
            if (parenthMatch) {
                const potentialAuthor = parenthMatch[1].trim();
                // Vérifier que ça ressemble à un nom de personne
                if (/^[A-ZÀ-Ü][a-zà-ü]+(\s+[A-ZÀ-Ü][a-zà-ü]+)*$/.test(potentialAuthor)) {
                    return potentialAuthor;
                }
            }
            
            // 3. Chercher dans le titre - format "Auteur - Œuvre" ou "Œuvre - Auteur"
            const dashMatch = title.match(/^([^—–\-]+)[—–\-](.+)$/);
            if (dashMatch) {
                const part1 = dashMatch[1].trim();
                const part2 = dashMatch[2].trim();
                // Tester si l'une des parties est un nom de personne
                if (/^[A-ZÀ-Ü][a-zà-ü]+(\s+[A-ZÀ-Ü][a-zà-ü]+)*$/.test(part1)) return part1;
                if (/^[A-ZÀ-Ü][a-zà-ü]+(\s+[A-ZÀ-Ü][a-zà-ü]+)*$/.test(part2)) return part2;
            }
            
            return 'Anonyme';
        }

        function detectTag(title, text) {
            const t = (title + ' ' + (text || '').substring(0, 500)).toLowerCase();
            const titleLower = title.toLowerCase();
            
            // Théâtre (prioritaire - mots très spécifiques)
            if (t.includes('acte ') || t.includes('scène ') || titleLower.includes('tragédie') || 
                titleLower.includes('comédie') || t.includes('personnages:') || t.includes('le chœur')) return 'théâtre';
            
            // Fable (prioritaire)
            if (titleLower.includes('fable') || (t.includes('morale') && t.includes('la fontaine'))) return 'fable';
            
            // Conte
            if (titleLower.includes('conte') || titleLower.includes('il était une fois')) return 'conte';
            
            // Poésie (mots spécifiques au genre)
            if (titleLower.includes('sonnet') || titleLower.includes('poème') || titleLower.includes('poésie') ||
                titleLower.includes('ode ') || titleLower.includes('ballade') || titleLower.includes('élégie') ||
                titleLower.includes('stances') || titleLower.includes('hymne') || titleLower.includes('rondeau') ||
                titleLower.includes('complainte') || titleLower.includes('chanson')) return 'poésie';
            // Détection poésie par structure (vers courts, rimes)
            const lines = (text || '').split('\n').slice(0, 20);
            const shortLines = lines.filter(l => l.trim().length > 5 && l.trim().length < 60);
            if (shortLines.length > 10) return 'poésie';
            
            // Nouvelle
            if (titleLower.includes('nouvelle')) return 'nouvelle';
            
            // Roman
            if (titleLower.includes('chapitre') || titleLower.includes('roman') || 
                titleLower.includes('livre ') || titleLower.includes('partie ')) return 'roman';
            
            // Philosophie (termes spécifiques)
            if (titleLower.includes('pensées') || titleLower.includes('maximes') || titleLower.includes('réflexions') ||
                titleLower.includes('essai') || titleLower.includes('discours sur') || titleLower.includes('traité') ||
                titleLower.includes('lettres à') || titleLower.includes('entretiens')) return 'philosophie';
            
            // Mystique (termes TRÈS spécifiques seulement)
            if (titleLower.includes('sermon') || titleLower.includes('oraison') || titleLower.includes('prière') ||
                titleLower.includes('méditation') || titleLower.includes('spirituel') || titleLower.includes('mystique') ||
                titleLower.includes('contemplation') || titleLower.includes('extase') || titleLower.includes('château intérieur') ||
                titleLower.includes('nuit obscure') || titleLower.includes('imitation de')) return 'mystique';
            
            return 'texte';
        }

        async function init() {
            // Initialiser Supabase (social features)
            initSupabase();
            
            loadState();
            
            // Restaurer le choix de langue ou détecter automatiquement
            const savedLang = localStorage.getItem('palimpseste_lang');
            const validLangs = ['all', ...WIKISOURCES.map(w => w.lang)];
            
            if (savedLang && validLangs.includes(savedLang)) {
                // Utiliser la langue sauvegardée
                selectedLang = savedLang;
            } else {
                // Détecter la langue du navigateur
                const browserLang = (navigator.language || navigator.userLanguage || 'fr').split('-')[0].toLowerCase();
                // Si la langue du navigateur est supportée, l'utiliser, sinon français par défaut
                selectedLang = validLangs.includes(browserLang) ? browserLang : 'fr';
                localStorage.setItem('palimpseste_lang', selectedLang);
            }
            
            const langSelect = document.getElementById('langSelect');
            if (langSelect) langSelect.value = selectedLang;
            
            updateStats();
            updateConnections();
            renderAchievements();
            renderReadingPath();
            renderFavorites();
            updateFavCount();
            updateFunStat();
            
            document.getElementById('loading').style.display = 'block';
            await fillPool();
            document.getElementById('loading').style.display = 'none';
            await loadMore();
            
            // Mise à jour périodique du fun stat
            setInterval(updateFunStat, 15000);
            
            window.onscroll = () => {
                document.getElementById('progress').style.width = 
                    (scrollY / (document.body.scrollHeight - innerHeight) * 100) + '%';
                if (innerHeight + scrollY >= document.body.scrollHeight - 800 && !state.loading) loadMore();
            };
        }

        function loadState() {
            try {
                const d = JSON.parse(localStorage.getItem('palimpseste') || '{}');
                state.likes = new Set(d.likes || []);
                state.readCount = d.readCount || 0;
                state.authorStats = d.authorStats || {};
                state.genreStats = d.genreStats || {};
                state.likedAuthors = new Set(d.likedAuthors || []);
                state.discoveredConnections = new Set(d.discoveredConnections || []);
                state.achievements = d.achievements || [];
                state.readingPath = d.readingPath || [];
                state.favorites = d.favorites || [];
                // Charger les stats de lecture
                state.readingStats = d.readingStats || {
                    totalWordsRead: 0,
                    totalReadingTime: 0,
                    streak: 0,
                    lastReadDate: null,
                    sessionsToday: 0,
                    bestStreak: 0,
                    dailyWords: {}
                };
                // Vérifier et mettre à jour le streak au chargement
                checkAndUpdateStreak();
            } catch(e) {}
        }

        function saveState() {
            localStorage.setItem('palimpseste', JSON.stringify({ 
                likes: [...state.likes], 
                readCount: state.readCount,
                authorStats: state.authorStats,
                genreStats: state.genreStats,
                likedAuthors: [...state.likedAuthors],
                discoveredConnections: [...state.discoveredConnections],
                achievements: state.achievements || [],
                readingPath: state.readingPath || [],
                favorites: state.favorites || [],
                readingStats: state.readingStats
            }));
            updateStats();
        }

        function updateStats() {
            // Mettre à jour les stats du panneau
            document.getElementById('totalRead').textContent = state.readCount;
            document.getElementById('likeCountPanel').textContent = state.likes.size;
            document.getElementById('authorCount').textContent = Object.keys(state.authorStats).length;
            
            // Titre dynamique selon le contexte
            updateDynamicHeader();
            
            // Mettre à jour les barres d'auteurs
            renderAuthorBars();
            renderGenreChart();
            
            // Mettre à jour les statistiques de lecture
            updateReadingStatsUI();
        }
        
        // ═══════════════════════════════════════════════════════════
        // 📊 STATISTIQUES DE LECTURE
        // ═══════════════════════════════════════════════════════════
        
        function getTodayKey() {
            return new Date().toISOString().split('T')[0];
        }
        
        function checkAndUpdateStreak() {
            const stats = state.readingStats;
            const today = getTodayKey();
            const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
            
            if (!stats.lastReadDate) {
                stats.streak = 0;
            } else if (stats.lastReadDate === today) {
                // Déjà lu aujourd'hui, streak maintenu
            } else if (stats.lastReadDate === yesterday) {
                // A lu hier, streak continue (sera incrémenté quand il lit aujourd'hui)
            } else {
                // Streak cassé
                stats.streak = 0;
            }
        }
        
        function recordReading(wordCount) {
            const stats = state.readingStats;
            const today = getTodayKey();
            const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
            
            // Ajouter les mots lus
            stats.totalWordsRead = (stats.totalWordsRead || 0) + wordCount;
            
            // Mots par jour
            if (!stats.dailyWords) stats.dailyWords = {};
            stats.dailyWords[today] = (stats.dailyWords[today] || 0) + wordCount;
            
            // Gérer le streak
            if (stats.lastReadDate !== today) {
                // Première lecture du jour
                if (stats.lastReadDate === yesterday || !stats.lastReadDate) {
                    stats.streak = (stats.streak || 0) + 1;
                } else {
                    stats.streak = 1; // Recommencer le streak
                }
                stats.lastReadDate = today;
                stats.sessionsToday = 1;
                
                // Meilleur streak
                if (stats.streak > (stats.bestStreak || 0)) {
                    stats.bestStreak = stats.streak;
                    if (stats.streak >= 7) {
                        toast('🔥 Streak record : ' + stats.streak + ' jours !');
                    }
                }
            } else {
                stats.sessionsToday = (stats.sessionsToday || 0) + 1;
            }
            
            saveState();
        }
        
        function startReadingTimer() {
            if (!sessionStartTime) {
                sessionStartTime = Date.now();
            }
        }
        
        function stopReadingTimer() {
            if (sessionStartTime) {
                const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
                state.readingStats.totalReadingTime = (state.readingStats.totalReadingTime || 0) + elapsed;
                sessionStartTime = null;
                saveState();
            }
        }
        
        function formatReadingTime(seconds) {
            if (seconds < 60) return seconds + ' sec';
            if (seconds < 3600) return Math.floor(seconds / 60) + ' min';
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return hours + 'h ' + mins + 'min';
        }
        
        function formatWordsCount(words) {
            if (words < 1000) return words.toString();
            if (words < 10000) return (words / 1000).toFixed(1) + 'k';
            return Math.floor(words / 1000) + 'k';
        }
        
        function updateReadingStatsUI() {
            const stats = state.readingStats;
            
            // Temps de lecture
            const timeEl = document.getElementById('totalReadingTime');
            if (timeEl) {
                timeEl.textContent = formatReadingTime(stats.totalReadingTime || 0);
            }
            
            // Mots lus
            const wordsEl = document.getElementById('totalWordsRead');
            if (wordsEl) {
                wordsEl.textContent = formatWordsCount(stats.totalWordsRead || 0);
            }
            
            // Streak
            const streakEl = document.getElementById('currentStreak');
            if (streakEl) {
                streakEl.textContent = stats.streak || 0;
            }
            
            // Barre de progression streak (objectif 7 jours)
            const progressEl = document.getElementById('streakProgress');
            if (progressEl) {
                const progress = Math.min(100, ((stats.streak || 0) / 7) * 100);
                progressEl.style.width = progress + '%';
            }
            
            // Hint streak
            const hintEl = document.getElementById('streakHint');
            if (hintEl) {
                const streak = stats.streak || 0;
                if (streak === 0) {
                    hintEl.textContent = 'Commencez à lire pour démarrer votre streak !';
                } else if (streak < 3) {
                    hintEl.textContent = `${streak} jour${streak > 1 ? 's' : ''} - Continuez demain !`;
                } else if (streak < 7) {
                    hintEl.textContent = `🔥 ${streak} jours ! Plus que ${7 - streak} pour la semaine complète !`;
                } else if (streak < 30) {
                    hintEl.textContent = `🔥🔥 ${streak} jours ! Vers le mois complet !`;
                } else {
                    hintEl.textContent = `🏆 ${streak} jours ! Incroyable dévotion !`;
                }
            }
            
            // Graphique hebdomadaire
            renderWeeklyChart();
        }
        
        function renderWeeklyChart() {
            const container = document.getElementById('weeklyChart');
            if (!container) return;
            
            const stats = state.readingStats;
            const dailyWords = stats.dailyWords || {};
            const days = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];
            const today = new Date();
            
            // Obtenir les 7 derniers jours
            const weekData = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const key = date.toISOString().split('T')[0];
                const dayOfWeek = date.getDay();
                weekData.push({
                    key,
                    dayLabel: days[(dayOfWeek + 6) % 7], // Lundi = 0
                    words: dailyWords[key] || 0,
                    isToday: i === 0
                });
            }
            
            // Trouver le max pour normaliser
            const maxWords = Math.max(100, ...weekData.map(d => d.words));
            
            container.innerHTML = weekData.map(d => {
                const height = Math.max(4, (d.words / maxWords) * 45);
                const classes = ['weekly-bar'];
                if (d.words > 0) classes.push('active');
                if (d.isToday) classes.push('today');
                return `<div class="${classes.join(' ')}" style="height: ${height}px" data-day="${d.dayLabel}" title="${d.words} mots"></div>`;
            }).join('');
        }
        
        // Détecter quand l'utilisateur quitte la page
        window.addEventListener('beforeunload', stopReadingTimer);
        window.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopReadingTimer();
            } else {
                startReadingTimer();
            }
        });
        
        // Phrases d'en-tête dynamiques selon l'état de l'exploration
        const HEADER_PHRASES = {
            start: [
                "Laissez-vous dériver...",
                "Un texte vous attend...",
                "La bibliothèque murmure...",
                "Plongez dans l'inconnu..."
            ],
            exploring: [
                "Le voyage continue...",
                "Vous vous enfoncez...",
                "Les pages tournent...",
                "Le labyrinthe s'ouvre..."
            ],
            deep: [
                "Vous êtes loin du rivage...",
                "Les profondeurs vous appellent...",
                "Le temps se suspend...",
                "Bienvenue dans l'abîme..."
            ],
            expert: [
                "Vous êtes un érudit...",
                "Les auteurs vous reconnaissent...",
                "Le palimpseste se révèle...",
                "Maître des mots anciens..."
            ]
        };
        
        function updateDynamicHeader() {
            const authorCount = Object.keys(state.authorStats).length;
            const readCount = state.readCount || 0;
            
            let phrases;
            if (readCount < 3) phrases = HEADER_PHRASES.start;
            else if (authorCount < 10) phrases = HEADER_PHRASES.exploring;
            else if (authorCount < 25) phrases = HEADER_PHRASES.deep;
            else phrases = HEADER_PHRASES.expert;
            
            const headerEl = document.getElementById('headerTitle');
            if (headerEl && Math.random() < 0.3) { // 30% de chance de changer
                headerEl.textContent = phrases[Math.floor(Math.random() * phrases.length)];
            }
        }
        
        function renderAuthorBars() {
            const container = document.getElementById('authorBars');
            const sorted = Object.entries(state.authorStats).sort((a, b) => b[1] - a[1]).slice(0, 8);
            const max = sorted[0]?.[1] || 1;
            const colors = ['#ff453a', '#ff9f0a', '#30d158', '#64d2ff', '#bf5af2', '#ff6482', '#ffd60a', '#ac8e68'];
            
            container.innerHTML = sorted.map(([author, count], i) => `
                <div class="author-bar">
                    <span class="author-bar-name">${author.split(' ').pop()}</span>
                    <div class="author-bar-track">
                        <div class="author-bar-fill" style="width: ${(count/max)*100}%; background: ${colors[i % colors.length]}"></div>
                    </div>
                    <span class="author-bar-count">${count}</span>
                </div>
            `).join('');
        }
        
        function renderGenreChart() {
            const container = document.getElementById('genreChart');
            container.innerHTML = Object.entries(state.genreStats).map(([genre, count]) => `
                <div class="genre-pill" onclick="exploreCategory('${genre}')" title="Explorer l'arborescence ${genre}">
                    <span class="genre-dot" style="background: ${GENRE_COLORS[genre] || '#6e6e73'}"></span>
                    ${genre} <strong>${count}</strong>
                </div>
            `).join('');
        }
        
        function trackStats(author, tag) {
            state.authorStats[author] = (state.authorStats[author] || 0) + 1;
            state.genreStats[tag] = (state.genreStats[tag] || 0) + 1;
            saveState();
        }
        
        // Construire dynamiquement les connexions entre auteurs
        // Les auteurs du même genre sont connectés entre eux
        function buildAuthorConnections(author, tag) {
            if (!author || author === 'Anonyme') return;
            
            // Trouver les autres auteurs du même genre
            const sameGenreAuthors = Object.keys(state.authorStats).filter(a => {
                // On considère que les auteurs vus récemment dans la même session sont "connectés"
                return a !== author && a !== 'Anonyme';
            });
            
            // Ajouter des connexions bidirectionnelles
            if (!authorConnections[author]) authorConnections[author] = [];
            
            // Connecter avec les 5 derniers auteurs différents découverts
            const recentAuthors = sameGenreAuthors.slice(-5);
            for (const other of recentAuthors) {
                if (!authorConnections[author].includes(other)) {
                    authorConnections[author].push(other);
                }
                if (!authorConnections[other]) authorConnections[other] = [];
                if (!authorConnections[other].includes(author)) {
                    authorConnections[other].push(author);
                }
            }
            
            // Limiter à 10 connexions par auteur
            if (authorConnections[author].length > 10) {
                authorConnections[author] = authorConnections[author].slice(-10);
            }
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🔍 RECHERCHE - Fonctions de recherche avancée
        // ═══════════════════════════════════════════════════════════
        
        let searchResults = {
            wikisource: [],
            poetrydb: [],
            gutenberg: [],
            users: []
        };
        let currentSearchTab = 'all';
        let currentSearchQuery = '';
        
        // Gérer l'affichage du bouton clear
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('searchInput');
            const searchClear = document.getElementById('searchClear');
            
            if (searchInput && searchClear) {
                searchInput.addEventListener('input', () => {
                    searchClear.classList.toggle('visible', searchInput.value.length > 0);
                });
            }
        });
        
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
                document.getElementById('searchClear')?.classList.remove('visible');
                searchInput.focus();
            }
        }
        
        // Fonction pour la barre de recherche principale
        function performMainSearch() {
            const input = document.getElementById('mainSearchInput');
            if (!input) return;
            const query = input.value.trim();
            if (!query || query.length < 2) {
                toast('⚠️ Entrez au moins 2 caractères');
                return;
            }
            // Réutiliser la logique de performSearch
            document.getElementById('searchInput').value = query;
            performSearch();
        }
        
        async function performSearch() {
            const mainInput = document.getElementById('mainSearchInput');
            const headerInput = document.getElementById('searchInput');
            const query = (mainInput?.value || headerInput?.value || '').trim();
            
            if (!query || query.length < 2) {
                toast('⚠️ Entrez au moins 2 caractères');
                return;
            }
            
            currentSearchQuery = query;
            
            // Afficher l'overlay avec loading
            const overlay = document.getElementById('searchResultsOverlay');
            const grid = document.getElementById('searchResultsGrid');
            const tabs = document.getElementById('searchResultsTabs');
            
            document.getElementById('searchQueryDisplay').textContent = query;
            overlay.classList.add('open');
            
            grid.innerHTML = '<div class="search-loading"><div class="spinner"></div><p>Recherche en cours...</p></div>';
            tabs.innerHTML = '';
            
            // Réinitialiser les résultats
            searchResults = { wikisource: [], poetrydb: [], gutenberg: [], users: [] };
            
            // Lancer les recherches en parallèle
            toast('🔍 Recherche...');
            
            await Promise.all([
                searchWikisource(query),
                searchPoetryDB(query),
                searchGutenberg(query),
                searchUsers(query)
            ]);
            
            // Afficher les résultats
            renderSearchTabs();
            renderSearchResults('all');
        }
        
        // Recherche d'utilisateurs sur Palimpseste
        async function searchUsers(query) {
            if (!supabaseClient) return;
            
            try {
                const { data: users } = await supabaseClient
                    .from('profiles')
                    .select('id, username, created_at')
                    .ilike('username', `%${query}%`)
                    .limit(20);
                
                if (users && users.length > 0) {
                    // Charger qui on suit
                    await loadUserFollowing();
                    
                    // Compter les extraits pour chaque user
                    searchResults.users = await Promise.all(users.map(async (u) => {
                        const { count } = await supabaseClient
                            .from('extraits')
                            .select('*', { count: 'exact', head: true })
                            .eq('user_id', u.id);
                        return {
                            ...u,
                            extraitCount: count || 0,
                            source: 'users'
                        };
                    }));
                }
            } catch (e) {
                console.error('User search error:', e);
            }
        }
        
        async function searchWikisource(query) {
            try {
                const wikisources = getActiveWikisources();
                const allResults = [];
                
                // Fonction pour chercher les œuvres d'un auteur via sa catégorie
                async function searchAuthorWorks(ws, authorName) {
                    const results = [];
                    // Normaliser le nom de l'auteur (première lettre majuscule pour chaque mot)
                    const normalizedName = authorName.trim().split(/\s+/)
                        .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
                        .join(' ');
                    
                    // D'abord, essayer de trouver la page Auteur pour récupérer le nom complet
                    let fullAuthorName = normalizedName;
                    try {
                        // Chercher la page Auteur avec le nom
                        const authorSearchUrl = `${ws.url}/w/api.php?action=query&list=search&srsearch=intitle:${encodeURIComponent(normalizedName)}&srnamespace=102&srlimit=5&format=json&origin=*`;
                        const authorSearchRes = await fetch(authorSearchUrl);
                        const authorSearchData = await authorSearchRes.json();
                        const authorPages = authorSearchData.query?.search || [];
                        
                        if (authorPages.length > 0) {
                            // Extraire le nom de la page Auteur (ex: "Auteur:Arthur Schopenhauer")
                            const authorPage = authorPages[0].title;
                            fullAuthorName = authorPage.replace(/^Auteur:|^Author:|^Autor:/, '').trim();
                        }
                    } catch (e) { /* Ignorer */ }
                    
                    // Essayer différents formats de catégorie selon la langue
                    const categoryFormats = {
                        'fr': [
                            `Catégorie:Œuvres d'${fullAuthorName}`,
                            `Catégorie:Œuvres de ${fullAuthorName}`,
                            `Catégorie:${fullAuthorName}`
                        ],
                        'en': [
                            `Category:Works by ${fullAuthorName}`,
                            `Category:${fullAuthorName}`
                        ],
                        'de': [
                            `Kategorie:${fullAuthorName}`,
                            `Kategorie:Werke von ${fullAuthorName}`
                        ],
                        'it': [
                            `Categoria:Opere di ${fullAuthorName}`,
                            `Categoria:${fullAuthorName}`
                        ],
                        'es': [
                            `Categoría:Obras de ${fullAuthorName}`,
                            `Categoría:${fullAuthorName}`
                        ]
                    };
                    
                    const categories = categoryFormats[ws.lang] || [`Category:${fullAuthorName}`];
                    
                    for (const catName of categories) {
                        try {
                            const catUrl = `${ws.url}/w/api.php?action=query&list=categorymembers&cmtitle=${encodeURIComponent(catName)}&cmlimit=20&cmnamespace=0&format=json&origin=*`;
                            const res = await fetch(catUrl);
                            const data = await res.json();
                            const members = data.query?.categorymembers || [];
                            if (members.length > 0) {
                                return members.map(m => ({
                                    title: m.title,
                                    snippet: `📚 Œuvre de ${fullAuthorName}`,
                                    source: 'wikisource',
                                    lang: ws.lang,
                                    wikisource: ws,
                                    isAuthorWork: true
                                }));
                            }
                        } catch (e) { /* Ignorer si catégorie non trouvée */ }
                    }
                    return results;
                }
                
                // Pour chaque wikisource, faire une recherche standard ET une recherche par auteur
                for (const ws of wikisources) {
                    // Recherche standard
                    const standardPromise = fetch(`${ws.url}/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=15&srnamespace=0&format=json&origin=*`)
                        .then(res => res.json())
                        .then(data => {
                            return (data.query?.search || []).map(r => ({
                                title: r.title,
                                snippet: r.snippet || '',
                                source: 'wikisource',
                                lang: ws.lang,
                                wikisource: ws
                            }));
                        })
                        .catch(() => []);
                    
                    // Recherche par catégorie d'auteur (si la requête ressemble à un nom)
                    const authorPromise = searchAuthorWorks(ws, query);
                    
                    const [standardResults, authorResults] = await Promise.all([standardPromise, authorPromise]);
                    
                    // Fusionner en mettant les œuvres de l'auteur en premier
                    const combined = [...authorResults, ...standardResults];
                    
                    // Dédupliquer par titre
                    const seen = new Set();
                    const unique = combined.filter(r => {
                        if (seen.has(r.title)) return false;
                        seen.add(r.title);
                        return true;
                    });
                    
                    allResults.push(...unique);
                }
                
                searchResults.wikisource = allResults;
            } catch (e) {
                console.error('Wikisource search error:', e);
            }
        }
        
        async function searchPoetryDB(query) {
            try {
                // Recherche par auteur
                const authorRes = await fetch(`https://poetrydb.org/author/${encodeURIComponent(query)}`);
                let authorData = [];
                if (authorRes.ok) {
                    const data = await authorRes.json();
                    if (Array.isArray(data)) {
                        authorData = data.slice(0, 10).map(p => ({
                            title: p.title,
                            author: p.author,
                            snippet: p.lines?.slice(0, 3).join(' / ') || '',
                            lines: p.lines,
                            source: 'poetrydb',
                            lang: 'en'
                        }));
                    }
                }
                
                // Recherche par titre
                const titleRes = await fetch(`https://poetrydb.org/title/${encodeURIComponent(query)}`);
                let titleData = [];
                if (titleRes.ok) {
                    const data = await titleRes.json();
                    if (Array.isArray(data)) {
                        titleData = data.slice(0, 10).map(p => ({
                            title: p.title,
                            author: p.author,
                            snippet: p.lines?.slice(0, 3).join(' / ') || '',
                            lines: p.lines,
                            source: 'poetrydb',
                            lang: 'en'
                        }));
                    }
                }
                
                // Combiner et dédupliquer
                const combined = [...authorData, ...titleData];
                const seen = new Set();
                searchResults.poetrydb = combined.filter(p => {
                    const key = p.title + p.author;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            } catch (e) {
                console.error('PoetryDB search error:', e);
            }
        }
        
        async function searchGutenberg(query) {
            try {
                const res = await fetch(`https://gutendex.com/books?search=${encodeURIComponent(query)}`);
                const data = await res.json();
                
                searchResults.gutenberg = (data.results || []).slice(0, 15).map(book => ({
                    title: book.title,
                    author: book.authors?.map(a => a.name).join(', ') || 'Inconnu',
                    snippet: book.subjects?.slice(0, 3).join(' • ') || '',
                    id: book.id,
                    source: 'gutenberg',
                    lang: book.languages?.[0] || 'en',
                    formats: book.formats
                }));
            } catch (e) {
                console.error('Gutenberg search error:', e);
            }
        }
        
        function renderSearchTabs() {
            const tabs = document.getElementById('searchResultsTabs');
            const totalAll = searchResults.wikisource.length + searchResults.poetrydb.length + searchResults.gutenberg.length;
            const usersCount = searchResults.users?.length || 0;
            
            tabs.innerHTML = `
                <button class="search-tab ${currentSearchTab === 'users' ? 'active' : ''}" onclick="switchSearchTab('users')">
                    👥 Utilisateurs <span class="count">${usersCount}</span>
                </button>
                <button class="search-tab ${currentSearchTab === 'all' ? 'active' : ''}" onclick="switchSearchTab('all')">
                    📚 Textes <span class="count">${totalAll}</span>
                </button>
                <button class="search-tab ${currentSearchTab === 'wikisource' ? 'active' : ''}" onclick="switchSearchTab('wikisource')">
                    📜 Wikisource <span class="count">${searchResults.wikisource.length}</span>
                </button>
                <button class="search-tab ${currentSearchTab === 'poetrydb' ? 'active' : ''}" onclick="switchSearchTab('poetrydb')">
                    🎭 Poésie <span class="count">${searchResults.poetrydb.length}</span>
                </button>
                <button class="search-tab ${currentSearchTab === 'gutenberg' ? 'active' : ''}" onclick="switchSearchTab('gutenberg')">
                    📖 Gutenberg <span class="count">${searchResults.gutenberg.length}</span>
                </button>
            `;
        }
        
        function switchSearchTab(tab) {
            currentSearchTab = tab;
            renderSearchTabs();
            renderSearchResults(tab);
        }
        
        function renderSearchResults(tab) {
            const grid = document.getElementById('searchResultsGrid');
            
            // Si onglet utilisateurs
            if (tab === 'users') {
                const users = searchResults.users || [];
                
                if (users.length === 0) {
                    grid.innerHTML = `
                        <div class="search-no-results">
                            <div class="search-no-results-icon">👤</div>
                            <p>Aucun utilisateur trouvé pour "${escapeHtml(currentSearchQuery)}"</p>
                            <p style="font-size: 0.8rem; margin-top: 0.5rem;">Vérifiez l'orthographe du pseudo</p>
                        </div>
                    `;
                    return;
                }
                
                grid.innerHTML = `
                    <div class="discover-grid" style="padding: 0.5rem;">
                        ${users.map(u => {
                            const isMe = currentUser && u.id === currentUser.id;
                            if (isMe) {
                                return `
                                    <div class="discover-card">
                                        <div class="discover-avatar" onclick="openUserProfile('${u.id}', '${u.username}')">${(u.username || '?').charAt(0).toUpperCase()}</div>
                                        <div class="discover-info" onclick="openUserProfile('${u.id}', '${u.username}')">
                                            <div class="discover-name">${escapeHtml(u.username || 'Anonyme')}</div>
                                            <div class="discover-stats">${u.extraitCount} extrait${u.extraitCount > 1 ? 's' : ''}</div>
                                        </div>
                                        <span style="color:var(--muted);font-size:0.8rem;">C'est vous</span>
                                    </div>
                                `;
                            }
                            return renderUserCard(
                                u.id, 
                                u.username, 
                                `${u.extraitCount} extrait${u.extraitCount > 1 ? 's' : ''}`,
                                true,
                                'toggleFollowFromSearch'
                            );
                        }).join('')}
                    </div>
                `;
                return;
            }
            
            let results = [];
            if (tab === 'all') {
                results = [
                    ...searchResults.wikisource,
                    ...searchResults.poetrydb,
                    ...searchResults.gutenberg
                ];
            } else {
                results = searchResults[tab] || [];
            }
            
            if (results.length === 0) {
                grid.innerHTML = `
                    <div class="search-no-results">
                        <div class="search-no-results-icon">📭</div>
                        <p>Aucun résultat pour "${escapeHtml(currentSearchQuery)}"</p>
                        <p style="font-size: 0.8rem; margin-top: 0.5rem;">Essayez avec d'autres mots-clés ou un nom d'auteur</p>
                    </div>
                `;
                return;
            }
            
            grid.innerHTML = results.map((r, idx) => {
                const sourceIcon = r.source === 'wikisource' ? '📜' : r.source === 'poetrydb' ? '🎭' : '📖';
                const sourceName = r.source === 'wikisource' ? 'Wikisource' : r.source === 'poetrydb' ? 'PoetryDB' : 'Gutenberg';
                const author = r.author || extractAuthorFromTitle(r.title) || '';
                
                // Nettoyer le snippet HTML
                let snippet = r.snippet || '';
                snippet = snippet.replace(/<[^>]*>/g, '').replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                
                // Highlight query dans le snippet
                const queryRegex = new RegExp(`(${escapeRegex(currentSearchQuery)})`, 'gi');
                snippet = snippet.replace(queryRegex, '<mark>$1</mark>');
                
                return `
                    <div class="search-result-card" onclick="openSearchResult(${idx}, '${r.source}')">
                        <div class="search-result-title">${escapeHtml(r.title)}</div>
                        ${author ? `<div class="search-result-author">${escapeHtml(author)}</div>` : ''}
                        <div class="search-result-snippet">${snippet}</div>
                        <div class="search-result-meta">
                            <span class="search-result-source">${sourceIcon} ${sourceName}</span>
                            ${r.lang ? `<span>🌐 ${r.lang.toUpperCase()}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Follow depuis la recherche
        async function toggleFollowFromSearch(userId, event) {
            event.stopPropagation();
            await toggleFollow(userId);
            // Re-render les résultats pour mettre à jour les boutons
            renderSearchResults(currentSearchTab);
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function extractAuthorFromTitle(title) {
            // Essayer d'extraire l'auteur depuis des patterns courants
            const patterns = [
                /^(.+?)\s*[-–—]\s*(.+)$/,  // "Titre - Auteur" ou "Auteur - Titre"
                /\(([^)]+)\)$/,             // "Titre (Auteur)"
                /by\s+(.+)$/i               // "Title by Author"
            ];
            
            for (const pattern of patterns) {
                const match = title.match(pattern);
                if (match) {
                    const candidate = match[1] || match[2];
                    // Vérifier si ça ressemble à un nom d'auteur
                    if (candidate && candidate.length < 50 && /^[A-Za-zÀ-ÿ\s.'-]+$/.test(candidate)) {
                        return candidate.trim();
                    }
                }
            }
            return null;
        }
        
        async function openSearchResult(idx, source) {
            let result;
            if (currentSearchTab === 'all') {
                const allResults = [
                    ...searchResults.wikisource,
                    ...searchResults.poetrydb,
                    ...searchResults.gutenberg
                ];
                result = allResults[idx];
            } else {
                result = searchResults[currentSearchTab]?.[idx];
            }
            
            if (!result) return;
            
            closeSearchResults();
            toast('📖 Chargement...');
            
            if (result.source === 'wikisource') {
                // Charger le texte depuis Wikisource
                const text = await fetchText(result.title, 0, result.wikisource);
                if (text) {
                    document.getElementById('feed').innerHTML = '';
                    state.cardIdx = 0;
                    renderCard(text, result.title, result.wikisource);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } else {
                    toast('❌ Impossible de charger ce texte');
                }
            } else if (result.source === 'poetrydb') {
                // Afficher directement le poème
                document.getElementById('feed').innerHTML = '';
                state.cardIdx = 0;
                renderCard({
                    title: result.title,
                    text: result.lines?.join('\n') || result.snippet,
                    author: result.author,
                    source: 'poetrydb'
                }, result.title, { lang: 'en', url: 'https://poetrydb.org', name: 'PoetryDB' });
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else if (result.source === 'gutenberg') {
                // Ouvrir le livre sur Gutenberg
                const readUrl = `https://www.gutenberg.org/ebooks/${result.id}`;
                window.open(readUrl, '_blank');
                toast('📖 Ouverture sur Project Gutenberg');
            }
        }
        
        function closeSearchResults() {
            document.getElementById('searchResultsOverlay').classList.remove('open');
        }
        
        async function shuffleFeed() {
            document.getElementById('feed').innerHTML = '';
            state.textPool = [];
            state.shownPages.clear();
            state.cardIdx = 0;
            toast('Nouveaux textes...');
            await fillPool();
            await loadMore();
        }

        function toast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        async function loadMore() {
            if (state.loading) return;
            state.loading = true;
            document.getElementById('loading').style.display = 'block';

            let loaded = 0, attempts = 0;
            while (loaded < 3 && attempts < 15) {
                attempts++;
                const isExploringCategory = currentCategoryPath.length > 0;
                if (state.textPool.length < 3 && !isExploringCategory) {
                    await fillPool();
                }
                if (state.textPool.length === 0) break;
                
                const item = state.textPool.shift();
                const itemKey = (item.source === 'poetrydb' ? 'poetrydb:' : '') + item.title;
                if (state.shownPages.has(itemKey)) continue;
                
                // Si c'est un item pré-chargé (PoetryDB), on l'affiche directement
                if (item.isPreloaded && item.text) {
                    state.shownPages.add(itemKey);
                    renderCard({
                        title: item.title,
                        text: item.text,
                        author: item.author,
                        source: item.source
                    }, item.title, { lang: item.lang, url: 'https://poetrydb.org', name: 'PoetryDB' });
                    loaded++;
                    continue;
                }
                
                // Sinon, récupérer depuis Wikisource
                const ws = item.wikisource || currentWikisource;
                const result = await fetchText(item.title, 0, ws);
                if (result?.text?.length > 150) {
                    state.shownPages.add(itemKey);
                    renderCard(result, item.title, ws);
                    loaded++;
                }
            }

            document.getElementById('loading').style.display = 'none';
            state.loading = false;
        }

        function renderCard(result, origTitle, wikisource = currentWikisource) {
            let title = result.title || origTitle;
            // Nettoyage agressif du titre
            title = title
                .replace(/<[^>]+>/g, '')  // Supprimer tout HTML
                .replace(/mw-page-title[^\s]*/gi, '')  // Supprimer classes MW
                .replace(/Liste des [^\/]*/gi, '')  // Supprimer "Liste des..."
                .replace(/par ordre alphabétique/gi, '')
                .replace(/span class/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            // Si le titre est invalide, ne pas afficher cette carte
            if (!isValidTitle(title)) return;
            
            const text = result.text;
            const lang = wikisource?.lang || 'fr';
            // Utiliser l'auteur des métadonnées en priorité
            const author = detectAuthor(title, text, result.author);
            const tag = detectTag(title, text);
            const url = `${wikisource?.url || 'https://fr.wikisource.org'}/wiki/${encodeURIComponent(origTitle)}`;
            const cardId = 'card-' + (state.cardIdx++);
            
            // Extraire un titre propre pour l'affichage
            let displayTitle = title.split('/').pop() || title.split('/')[0];
            // Si c'est un titre générique, prendre la première partie
            if (displayTitle.length < 3) displayTitle = title.split('/')[0];
            // Supprimer les parenthèses avec l'auteur si redondant
            displayTitle = displayTitle.replace(/\s*\([^)]*\)\s*$/, '').trim();
            // Si displayTitle est vide ou trop court après nettoyage, utiliser le titre original
            if (displayTitle.length < 3) displayTitle = title.split('/')[0] || 'Texte sans titre';
            
            // Badge de langue
            const langBadge = lang !== 'fr' ? `<span class="lang-badge">${lang.toUpperCase()}</span>` : '';
            
            // Tracker les stats et construire les connexions
            trackStats(author, tag);
            buildAuthorConnections(author, tag);

            // Découper le texte en teaser + suite
            const TEASER_LENGTH = 350;
            const CHUNK_LENGTH = 600;
            let teaser = text;
            let remaining = '';
            
            if (text.length > TEASER_LENGTH) {
                // Couper proprement sur une phrase ou un retour à la ligne
                let cutPoint = text.lastIndexOf('. ', TEASER_LENGTH);
                if (cutPoint < TEASER_LENGTH * 0.5) cutPoint = text.lastIndexOf('\n', TEASER_LENGTH);
                if (cutPoint < TEASER_LENGTH * 0.5) cutPoint = text.lastIndexOf(' ', TEASER_LENGTH);
                if (cutPoint < TEASER_LENGTH * 0.5) cutPoint = TEASER_LENGTH;
                teaser = text.substring(0, cutPoint + 1).trim();
                remaining = text.substring(cutPoint + 1).trim();
            }
            
            const card = document.createElement('div');
            card.className = 'card';
            card.id = cardId;
            card.innerHTML = `
                <div class="card-head" onclick="showRelatedAuthors('${cardId}')" style="cursor:pointer;" title="Cliquer pour découvrir des auteurs proches">
                    <div>
                        <div class="author">${esc(author)} ${langBadge} <span class="explore-hint">🕸️</span></div>
                        <div class="work">${esc(displayTitle)}</div>
                    </div>
                    <span class="tag ${tag}" onclick="event.stopPropagation(); exploreCategory('${tag}')" title="Explorer ce genre">${tag}</span>
                </div>
                <div class="card-body" ondblclick="doubleTapLike('${cardId}', event)">
                    <span class="like-heart-overlay" id="heart-${cardId}">❤️</span>
                    <div class="text-teaser">${esc(teaser)}</div>
                    <div class="text-full" id="full-${cardId}"></div>
                    ${remaining ? `<button class="btn-suite" onclick="showMore('${cardId}')" id="suite-${cardId}">Lire la suite<span class="arrow">→</span></button>` : ''}
                </div>
                <div class="related-authors" id="related-${cardId}" style="display:none;"></div>
                <div class="card-foot">
                    <div class="actions">
                        <button class="btn" onclick="toggleLike('${cardId}',this)">♥</button>
                        <button class="btn btn-share" onclick="shareCardExtrait('${cardId}')" title="Partager cet extrait">🐦 Partager</button>
                        <button class="btn" onclick="quickShareAndComment('${cardId}')" title="Partager et commenter">💬</button>
                        <button class="btn" onclick="showRelatedAuthors('${cardId}')" title="Explorer auteurs proches">🔗</button>
                        <a class="btn" href="${url}" target="_blank">↗ Wikisource</a>
                    </div>
                </div>
            `;
            card.dataset.title = title;
            card.dataset.author = author;
            card.dataset.text = text;
            card.dataset.remaining = remaining;
            card.dataset.shown = '0';
            card.dataset.tag = tag;
            card.dataset.lang = lang;
            card.dataset.chunkSize = CHUNK_LENGTH;
            document.getElementById('feed').appendChild(card);
            setTimeout(() => card.classList.add('show'), 50);
            
            // Tracker ce texte comme lu
            state.readCount++;
            const teaserWords = teaser.split(/\s+/).filter(w => w.length > 0).length;
            recordReading(teaserWords);
            startReadingTimer();
            
            // Mettre à jour l'affichage
            updateStats();
            saveState();
        }

        function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>'); }
        
        // Afficher la suite du texte - tout d'un coup au premier clic
        function showMore(cardId) {
            const card = document.getElementById(cardId);
            if (!card) return;
            
            const fullEl = document.getElementById('full-' + cardId);
            const btnEl = document.getElementById('suite-' + cardId);
            if (!fullEl || !btnEl) return;
            
            let remaining = card.dataset.remaining || '';
            
            if (!remaining) {
                btnEl.innerHTML = '✓ Texte complet';
                btnEl.classList.add('exhausted');
                btnEl.onclick = null;
                return;
            }
            
            // Afficher TOUT le texte restant d'un coup
            const chunkEl = document.createElement('div');
            chunkEl.className = 'text-chunk';
            chunkEl.style.animation = 'fadeIn 0.4s ease';
            chunkEl.innerHTML = esc(remaining);
            fullEl.appendChild(chunkEl);
            fullEl.classList.add('visible');
            
            // Tracker les mots lus
            const wordCount = remaining.split(/\s+/).filter(w => w.length > 0).length;
            recordReading(wordCount);
            startReadingTimer();
            
            // Marquer comme complet
            card.dataset.remaining = '';
            
            // Mettre à jour le bouton
            btnEl.innerHTML = '✓ Texte complet';
            btnEl.classList.add('exhausted');
            btnEl.onclick = null;
            
            // Scroll doux vers le nouveau contenu
            setTimeout(() => chunkEl.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
        }
        
        function toggleLike(id, btn) {
            const card = document.getElementById(id);
            const author = card?.dataset?.author;
            const title = card?.dataset?.title;
            const text = card?.dataset?.text;
            
            if (state.likes.has(id)) { 
                state.likes.delete(id); 
                // Supprimer des favoris stockés
                state.favorites = (state.favorites || []).filter(f => f.id !== id);
                btn?.classList?.remove('active');
                // Retirer l'auteur des likedAuthors si plus aucune carte likée
                if (author && author !== 'Anonyme') {
                    const hasOtherLikes = [...state.likes].some(likeId => {
                        const c = document.getElementById(likeId);
                        return c?.dataset?.author === author;
                    });
                    if (!hasOtherLikes) state.likedAuthors.delete(author);
                }
            } else { 
                state.likes.add(id); 
                // Ajouter aux favoris stockés
                if (!state.favorites) state.favorites = [];
                state.favorites.push({
                    id: id,
                    title: title,
                    author: author,
                    text: text?.substring(0, 200) || '',
                    timestamp: Date.now()
                });
                btn?.classList?.add('active'); 
                toast('💎 Ajouté aux favoris');
                // Ajouter l'auteur aux likedAuthors
                if (author && author !== 'Anonyme') {
                    state.likedAuthors.add(author);
                }
            }
            saveState();
            updateConnections();
            renderFavorites();
            updateFavCount();
        }
        
        // Double-tap pour liker (style Instagram)
        function doubleTapLike(id, event) {
            event.preventDefault();
            const card = document.getElementById(id);
            const heart = document.getElementById('heart-' + id);
            const likeBtn = card?.querySelector('.card-foot .btn');
            
            // Afficher l'animation du coeur
            if (heart) {
                heart.classList.remove('animate');
                void heart.offsetWidth; // Force reflow
                heart.classList.add('animate');
            }
            
            // Si pas déjà liké, liker
            if (!state.likes.has(id)) {
                toggleLike(id, likeBtn);
            } else {
                // Déjà liké, juste montrer le coeur (feedback visuel)
                toast('❤️ Déjà dans tes favoris !');
            }
        }
        
        // Afficher la liste des favoris dans le panneau
        function renderFavorites() {
            const container = document.getElementById('favoritesList');
            if (!container) return;
            
            const favorites = state.favorites || [];
            
            if (favorites.length === 0) {
                container.innerHTML = '<div class="favorites-empty">Cliquez ♥ pour sauvegarder</div>';
                return;
            }
            
            // Trier par date (plus récent d'abord)
            const sorted = [...favorites].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            
            container.innerHTML = sorted.map(fav => `
                <div class="favorite-item" onclick="scrollToCard('${fav.id}')">
                    <div class="favorite-content">
                        <div class="favorite-title">${esc(fav.title?.split('/').pop() || fav.title || 'Sans titre')}</div>
                        <div class="favorite-author">${esc(fav.author || 'Anonyme')}</div>
                        <div class="favorite-preview">${esc(fav.text || '')}</div>
                    </div>
                    <button class="favorite-remove" onclick="event.stopPropagation(); removeFavorite('${fav.id}')" title="Retirer">✕</button>
                </div>
            `).join('');
        }
        
        function scrollToCard(cardId) {
            const card = document.getElementById(cardId);
            if (card) {
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                card.style.boxShadow = '0 0 30px rgba(255,69,58,0.5)';
                setTimeout(() => card.style.boxShadow = '', 2000);
            }
        }
        
        function removeFavorite(id) {
            state.likes.delete(id);
            state.favorites = (state.favorites || []).filter(f => f.id !== id);
            const btn = document.querySelector(`#${id} .btn.active`);
            if (btn) btn.classList.remove('active');
            saveState();
            renderFavorites();
            updateFavCount();
            toast('Retiré des favoris');
        }
        
        // === VUE FAVORIS COMPLÈTE ===
        function openFavoritesView() {
            const overlay = document.getElementById('favoritesOverlay');
            const grid = document.getElementById('favoritesGrid');
            if (!overlay || !grid) return;
            
            const favorites = state.favorites || [];
            
            if (favorites.length === 0) {
                grid.innerHTML = `
                    <div class="fav-empty">
                        <div class="fav-empty-icon">♥</div>
                        <div class="fav-empty-text">Aucun favori pour l'instant</div>
                        <p style="margin-top: 1rem; color: var(--muted); font-size: 0.9rem;">
                            Cliquez sur le cœur ♥ d'un texte pour le sauvegarder ici
                        </p>
                    </div>
                `;
            } else {
                const sorted = [...favorites].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                
                grid.innerHTML = sorted.map(fav => `
                    <div class="fav-card">
                        <div class="fav-card-head">
                            <div>
                                <div class="fav-card-author">${esc(fav.author || 'Anonyme')}</div>
                                <div class="fav-card-title">${esc(fav.title?.split('/').pop() || fav.title || 'Sans titre')}</div>
                            </div>
                        </div>
                        <div class="fav-card-text">${esc(fav.text || '').substring(0, 500)}${(fav.text?.length || 0) > 500 ? '...' : ''}</div>
                        <div class="fav-card-actions">
                            <button class="btn" onclick="openFavInReader('${fav.id}')">Lire</button>
                            <button class="btn" onclick="removeFavoriteFromView('${fav.id}')">Retirer</button>
                        </div>
                    </div>
                `).join('');
            }
            
            overlay.classList.add('open');
            document.body.style.overflow = 'hidden';
        }
        
        function closeFavoritesView() {
            const overlay = document.getElementById('favoritesOverlay');
            if (overlay) {
                overlay.classList.remove('open');
                document.body.style.overflow = '';
            }
        }
        
        function openFavInReader(id) {
            const fav = (state.favorites || []).find(f => f.id === id);
            if (fav) {
                closeFavoritesView();
                // Chercher la carte dans le feed ou créer une vue reader
                const card = document.getElementById(id);
                if (card) {
                    const btn = card.querySelector('.read-more-btn');
                    if (btn) btn.click();
                    else {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    // Ouvrir directement dans le reader avec le texte sauvegardé
                    openReaderWithFav(fav);
                }
            }
        }
        
        function openReaderWithFav(fav) {
            const overlay = document.getElementById('readerOverlay');
            const content = document.getElementById('readerContent');
            if (!overlay || !content) return;
            
            content.innerHTML = `
                <div style="text-align:center; margin-bottom: 3rem;">
                    <div style="font-family: 'Playfair Display', serif; font-size: 1.5rem; font-weight: 600;">${esc(fav.author || 'Anonyme')}</div>
                    <div style="color: var(--muted); font-style: italic; margin-top: 0.5rem;">${esc(fav.title?.split('/').pop() || fav.title || '')}</div>
                </div>
                <div style="white-space: pre-wrap; text-align: justify;">${esc(fav.text || 'Texte non disponible')}</div>
            `;
            
            overlay.classList.add('open');
            document.body.style.overflow = 'hidden';
        }
        
        function removeFavoriteFromView(id) {
            removeFavorite(id);
            // Re-render la vue favoris
            openFavoritesView();
        }
        
        function updateFavCount() {
            const countEl = document.getElementById('favCount');
            if (countEl) {
                const count = (state.favorites || []).length;
                countEl.textContent = count;
            }
        }
        
        // Trouver les auteurs connexes basés sur les favoris et les découvertes
        function getConnectedAuthors() {
            const connected = new Map(); // auteur -> source(s)
            
            // Utiliser les auteurs découverts comme base de recommandation
            // Un auteur "similaire" est un auteur lu dans la même session mais pas encore liké
            for (const likedAuthor of state.likedAuthors) {
                // Chercher des auteurs découverts récemment (dans authorConnections dynamique)
                const connections = authorConnections[likedAuthor] || [];
                for (const connectedAuthor of connections) {
                    // Ne pas recommander un auteur déjà lu/liké
                    if (state.likedAuthors.has(connectedAuthor)) continue;
                    if (state.discoveredConnections.has(connectedAuthor)) continue;
                    
                    if (!connected.has(connectedAuthor)) {
                        connected.set(connectedAuthor, []);
                    }
                    connected.get(connectedAuthor).push(likedAuthor);
                }
            }
            
            // Trier par nombre de connexions (auteurs recommandés par plusieurs sources d'abord)
            return [...connected.entries()]
                .sort((a, b) => b[1].length - a[1].length)
                .slice(0, 6);
        }
        
        // Mettre à jour l'affichage des connexions
        function updateConnections() {
            const connected = getConnectedAuthors();
            const section = document.getElementById('connectionsSection');
            const graph = document.getElementById('connectionGraph');
            const recoBanner = document.getElementById('recoBanner');
            const recoAuthors = document.getElementById('recoAuthors');
            
            if (connected.length === 0) {
                section.style.display = 'none';
                recoBanner.style.display = 'none';
                return;
            }
            
            // Afficher la section dans le panneau
            section.style.display = 'block';
            graph.innerHTML = connected.map(([author, sources]) => {
                const isDiscovered = state.discoveredConnections.has(author);
                const sourceList = sources.slice(0, 2).join(', ');
                return `
                    <div class="connection-item" onclick="exploreAuthor('${author.replace(/'/g, "\\'")}')">
                        <div class="connection-node ${isDiscovered ? 'discovered' : ''}">
                            <span class="connection-dot"></span>
                            <span>${author}</span>
                        </div>
                        <div class="connection-label">via ${sourceList}</div>
                    </div>
                `;
            }).join('');
            
            // Afficher la bannière de recommandation
            recoBanner.style.display = 'block';
            recoAuthors.innerHTML = connected.slice(0, 4).map(([author]) => `
                <span class="reco-author" onclick="exploreAuthor('${author.replace(/'/g, "\\'")}')">${author}</span>
            `).join('');
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🕸️ AFFICHER LES AUTEURS LIÉS À UN TEXTE (clic sur carte)
        // ═══════════════════════════════════════════════════════════
        function showRelatedAuthors(cardId) {
            const card = document.getElementById(cardId);
            if (!card) return;
            
            const author = card.dataset.author;
            const container = document.getElementById('related-' + cardId);
            
            // Toggle : si déjà visible, cacher
            if (container.style.display !== 'none') {
                container.style.display = 'none';
                return;
            }
            
            // Trouver les auteurs connectés (dynamiquement découverts)
            const connected = authorConnections[author] || [];
            
            // Ajouter des suggestions basées sur le genre
            const tag = card.dataset.tag;
            const genreAuthors = getAuthorsForGenre(tag, author);
            
            // Combiner et dédupliquer
            const allRelated = [...new Set([...connected, ...genreAuthors])].slice(0, 6);
            
            if (allRelated.length === 0) {
                container.innerHTML = `<div class="no-related">Aucune connexion connue. <button class="btn btn-small" onclick="randomJump()">🎲 Hasard</button></div>`;
            } else {
                container.innerHTML = `
                    <div class="related-title">🕸️ Auteurs proches de ${author.split(' ').pop()}</div>
                    <div class="related-list">
                        ${allRelated.map(a => `
                            <button class="related-btn" onclick="exploreAuthor('${a.replace(/'/g, "\\'")}')">
                                ${a.split(' ').pop()}
                            </button>
                        `).join('')}
                    </div>
                `;
            }
            
            container.style.display = 'block';
            toast(`${allRelated.length} auteur(s) à explorer`);
        }
        
        // Trouver des auteurs du même genre (classiques mondiaux + dynamique)
        function getAuthorsForGenre(genre, excludeAuthor) {
            // Auteurs classiques par genre (mix mondial)
            const genreMap = {
                'poésie': ['Baudelaire', 'Rimbaud', 'Shakespeare', 'Goethe', 'Dante', 'Petrarca', 'Pushkin', 'Neruda'],
                'poetry': ['Shakespeare', 'Keats', 'Byron', 'Wordsworth', 'Dickinson', 'Whitman', 'Poe'],
                'théâtre': ['Molière', 'Shakespeare', 'Goethe', 'Calderón', 'Goldoni', 'Chekhov'],
                'drama': ['Shakespeare', 'Marlowe', 'Ibsen', 'Chekhov', 'Wilde'],
                'roman': ['Balzac', 'Dickens', 'Dostoevsky', 'Tolstoy', 'Cervantes', 'Mann'],
                'novel': ['Dickens', 'Austen', 'Brontë', 'Twain', 'Melville', 'James'],
                'conte': ['Perrault', 'Grimm', 'Andersen', 'Maupassant'],
                'tale': ['Grimm', 'Andersen', 'Wilde', 'Poe'],
                'fable': ['La Fontaine', 'Ésope', 'Aesop', 'Krylov'],
                'texte': ['Hugo', 'Goethe', 'Dante', 'Cervantes'],
                'text': ['Milton', 'Bunyan', 'Swift', 'Defoe']
            };
            
            // Ajouter les auteurs découverts dynamiquement pour ce genre
            const discovered = Object.keys(state.authorStats);
            const baseList = genreMap[genre?.toLowerCase()] || [];
            const combined = [...baseList, ...discovered];
            
            return [...new Set(combined)]
                .filter(a => a !== excludeAuthor && a !== 'Anonyme')
                .sort(() => Math.random() - 0.5)
                .slice(0, 4);
        }
        
        // Explorer un auteur spécifique (recherche ciblée)
        async function exploreAuthor(author) {
            toast(`Exploration de ${author}...`);
            state.discoveredConnections.add(author);
            saveState();
            
            // Recherches spécifiques pour cet auteur
            const searches = [`${author} poem`, `${author} text`, `${author} sonnet`];
            
            // Utiliser les wikisources actives selon le filtre
            const activeSources = getActiveWikisources();
            const shuffledWS = [...activeSources].sort(() => Math.random() - 0.5).slice(0, Math.min(3, activeSources.length));
            
            for (const ws of shuffledWS) {
                for (const query of searches) {
                    const results = await searchTexts(query, 3, ws);
                    for (const r of results) {
                        if (!state.shownPages.has(r.title) && isValidTitle(r.title)) {
                            state.textPool.unshift({ ...r, wikisource: ws }); // Ajouter en priorité
                        }
                    }
                }
            }
            
            // Charger immédiatement
            await loadMore();
            updateConnections();
            
            // Scroll vers le nouveau contenu
            window.scrollTo({ top: document.body.scrollHeight - window.innerHeight - 400, behavior: 'smooth' });
        }

        function openReader(id) {
            const card = document.getElementById(id);
            if (!card) return;
            const author = card.dataset.author;
            const title = card.dataset.title;
            const text = card.dataset.text || '';
            document.getElementById('readerTitle').textContent = `${author} — ${title.split('/')[0]}`;
            document.getElementById('readerContent').innerHTML = esc(text);
            document.getElementById('reader').classList.add('open');
            document.body.style.overflow = 'hidden';
            state.readCount++;
            
            // Tracker les mots lus
            const wordCount = text.split(/\s+/).filter(w => w.length > 0).length;
            recordReading(wordCount);
            startReadingTimer();
            
            saveState();
            
            // Fonctionnalités fun
            addToReadingPath(author, title);
            checkAchievements();
            updateFunStat();
            updateStats();
        }

        function closeReader() {
            document.getElementById('reader').classList.remove('open');
            document.body.style.overflow = '';
            stopReadingTimer();
        }

        // ═══════════════════════════════════════════════════════════
        // � AMBIANCES DE LECTURE
        // ═══════════════════════════════════════════════════════════
        
        const AMBIANCES = {
            libre: {
                name: 'Dérive libre',
                icon: '🌊',
                description: 'Laissez-vous porter par le hasard des textes',
                authors: [], // Utilise les auteurs par défaut
                keywords: [],
                color: '#64b5f6'
            },
            gothique: {
                name: 'Gothique',
                icon: '🦇',
                description: 'Châteaux hantés, spectres et terreurs nocturnes',
                authors: ['Edgar Allan Poe', 'Ann Radcliffe', 'Matthew Lewis', 'Horace Walpole', 'Mary Shelley', 'Bram Stoker', 'Charles Maturin', 'Sheridan Le Fanu', 'Théophile Gautier', 'Villiers de l\'Isle-Adam'],
                keywords: ['fantôme', 'spectre', 'château', 'terreur', 'nuit', 'vampire', 'mort', 'tombe', 'ténèbres', 'effroi'],
                color: '#6a1b9a'
            },
            surrealiste: {
                name: 'Surréaliste',
                icon: '🎭',
                description: 'L\'inconscient libéré, les rêves éveillés',
                authors: ['André Breton', 'Paul Éluard', 'Robert Desnos', 'Philippe Soupault', 'Louis Aragon', 'Benjamin Péret', 'René Crevel', 'Antonin Artaud', 'Lautréamont', 'Alfred Jarry'],
                keywords: ['rêve', 'automatique', 'hasard', 'inconscient', 'merveilleux', 'étrange', 'absurde'],
                color: '#ff6f00'
            },
            romantique: {
                name: 'Romantique',
                icon: '🌹',
                description: 'Passions intenses et âmes tourmentées',
                authors: ['Victor Hugo', 'Alphonse de Lamartine', 'Alfred de Musset', 'Alfred de Vigny', 'Gérard de Nerval', 'François-René de Chateaubriand', 'George Sand', 'Lord Byron', 'Percy Shelley', 'John Keats'],
                keywords: ['amour', 'passion', 'coeur', 'âme', 'sentiment', 'larmes', 'désespoir', 'nature'],
                color: '#e91e63'
            },
            melancolie: {
                name: 'Mélancolie',
                icon: '🌧️',
                description: 'Spleen, tristesse douce et contemplation',
                authors: ['Charles Baudelaire', 'Paul Verlaine', 'Jules Laforgue', 'Maurice Rollinat', 'Sully Prudhomme', 'Albert Samain', 'Francis Jammes', 'Giacomo Leopardi'],
                keywords: ['spleen', 'ennui', 'tristesse', 'automne', 'pluie', 'brume', 'solitude', 'regret', 'nostalgie'],
                color: '#546e7a'
            },
            mystique: {
                name: 'Mystique',
                icon: '🔮',
                description: 'Quêtes spirituelles et visions ésotériques',
                authors: ['William Blake', 'Emanuel Swedenborg', 'Jakob Böhme', 'Angelus Silesius', 'San Juan de la Cruz', 'Sainte Thérèse d\'Avila', 'Maître Eckhart', 'Hildegarde de Bingen', 'Rûmî'],
                keywords: ['âme', 'divin', 'extase', 'vision', 'lumière', 'éternel', 'sacré', 'céleste', 'spirituel'],
                color: '#7e57c2'
            },
            epique: {
                name: 'Épique',
                icon: '⚔️',
                description: 'Héros, batailles et destinées grandioses',
                authors: ['Homère', 'Virgile', 'Le Tasse', 'L\'Arioste', 'Milton', 'Camoens', 'Dante Alighieri', 'Victor Hugo'],
                keywords: ['héros', 'bataille', 'gloire', 'honneur', 'guerre', 'victoire', 'destin', 'épée', 'conquête'],
                color: '#d32f2f'
            },
            pastoral: {
                name: 'Pastoral',
                icon: '🌾',
                description: 'Campagnes idylliques et nature apaisante',
                authors: ['Théocrite', 'Virgile', 'Pierre de Ronsard', 'Joachim du Bellay', 'Maurice Scève', 'Francis Jammes', 'Jean Giono', 'Colette'],
                keywords: ['berger', 'prairie', 'champ', 'fleur', 'ruisseau', 'oiseau', 'printemps', 'nature', 'campagne'],
                color: '#66bb6a'
            },
            decadent: {
                name: 'Décadent',
                icon: '💀',
                description: 'Fin de siècle, artifice et beauté morbide',
                authors: ['Joris-Karl Huysmans', 'Jean Lorrain', 'Rachilde', 'Villiers de l\'Isle-Adam', 'Jules Barbey d\'Aurevilly', 'Oscar Wilde', 'Gabriele D\'Annunzio', 'Maurice Rollinat'],
                keywords: ['artifice', 'opium', 'décadence', 'luxe', 'pervers', 'morbide', 'exquis', 'raffiné', 'poison'],
                color: '#4a148c'
            },
            antique: {
                name: 'Antique',
                icon: '🏛️',
                description: 'Sagesse grecque et grandeur romaine',
                authors: ['Homère', 'Sophocle', 'Euripide', 'Platon', 'Aristote', 'Virgile', 'Ovide', 'Horace', 'Sénèque', 'Marc Aurèle', 'Cicéron'],
                keywords: ['Olympe', 'dieux', 'muse', 'oracle', 'temple', 'philosophe', 'vertu', 'sagesse'],
                color: '#8d6e63'
            },
            voyage: {
                name: 'Voyage',
                icon: '🚢',
                description: 'Horizons lointains et découvertes',
                authors: ['Jules Verne', 'Pierre Loti', 'Joseph Conrad', 'Herman Melville', 'Robert Louis Stevenson', 'Jack London', 'Marco Polo', 'Ibn Battûta'],
                keywords: ['voyage', 'mer', 'île', 'horizon', 'aventure', 'découverte', 'navire', 'explorateur', 'orient'],
                color: '#0288d1'
            },
            philosophie: {
                name: 'Philosophie',
                icon: '🧠',
                description: 'Méditations sur l\'existence et la pensée',
                authors: ['Platon', 'Aristote', 'Montaigne', 'Blaise Pascal', 'René Descartes', 'Jean-Jacques Rousseau', 'Voltaire', 'Friedrich Nietzsche', 'Arthur Schopenhauer', 'Sénèque'],
                keywords: ['pensée', 'raison', 'vérité', 'existence', 'mort', 'liberté', 'sagesse', 'doute', 'être'],
                color: '#455a64'
            }
        };
        
        let currentAmbiance = 'libre';
        
        // Changer d'ambiance
        async function setAmbiance(ambianceId) {
            const ambiance = AMBIANCES[ambianceId];
            if (!ambiance) return;
            
            currentAmbiance = ambianceId;
            
            // Mettre à jour l'UI
            document.querySelectorAll('.ambiance-pill').forEach(pill => {
                pill.classList.toggle('active', pill.dataset.ambiance === ambianceId);
            });
            
            // Afficher l'intro si ce n'est pas "libre"
            const introEl = document.getElementById('ambianceIntro');
            if (ambianceId !== 'libre') {
                introEl.innerHTML = `
                    <button class="close-intro" onclick="closeAmbianceIntro()" title="Fermer">✕</button>
                    <h2>${ambiance.icon} ${ambiance.name}</h2>
                    <p>${ambiance.description}</p>
                    <div class="ambiance-tags">
                        ${ambiance.authors.slice(0, 5).map(a => `<span class="ambiance-tag" onclick="exploreFromAmbiance('${a.replace(/'/g, "\\'")}'" title="Explorer ${a}">${a}</span>`).join('')}
                        ${ambiance.authors.length > 5 ? `<span class="ambiance-tag more-authors" title="${ambiance.authors.slice(5).join(', ')}">+${ambiance.authors.length - 5} auteurs</span>` : ''}
                    </div>
                `;
                introEl.style.display = 'block';
                introEl.style.position = 'relative';
            } else {
                introEl.style.display = 'none';
            }
            
            // Effacer le feed et recharger avec la nouvelle ambiance
            document.getElementById('feed').innerHTML = '';
            state.loading = false;
            
            // Toast
            toast(`${ambiance.icon} Mode ${ambiance.name} activé`);
            
            // Charger les textes de cette ambiance
            await loadAmbianceContent(ambianceId);
        }
        
        // Fermer l'intro d'ambiance
        function closeAmbianceIntro() {
            const introEl = document.getElementById('ambianceIntro');
            introEl.style.display = 'none';
        }
        
        // Explorer un auteur depuis l'encart d'ambiance
        async function exploreFromAmbiance(author) {
            toast(`🔍 Exploration de ${author}...`);
            await exploreAuthor(author);
        }
        
        // Charger le contenu d'une ambiance
        async function loadAmbianceContent(ambianceId) {
            const ambiance = AMBIANCES[ambianceId];
            
            if (ambianceId === 'libre' || !ambiance.authors.length) {
                // Mode libre : utiliser le comportement par défaut
                await exploreAuthor(DEFAULT_AUTHORS[Math.floor(Math.random() * DEFAULT_AUTHORS.length)]);
                return;
            }
            
            // Choisir des auteurs/mots-clés de l'ambiance au hasard
            const shuffledAuthors = [...ambiance.authors].sort(() => Math.random() - 0.5);
            const shuffledKeywords = [...ambiance.keywords].sort(() => Math.random() - 0.5);
            
            // Charger 2-3 auteurs + 1-2 mots-clés pour variété
            const toLoad = [
                ...shuffledAuthors.slice(0, 2),
                ...shuffledKeywords.slice(0, 1)
            ];
            
            for (const term of toLoad) {
                await exploreAuthor(term);
            }
        }
        
        // Modifier randomJump pour respecter l'ambiance
        // ═══════════════════════════════════════════════════════════
        // �🎲 FONCTIONNALITÉS FUN - Le génie des graphes
        // ═══════════════════════════════════════════════════════════
        
        // Auteurs "secrets" - pépites cachées mondiales à découvrir
        const HIDDEN_GEMS = [
            // Français
            'Lautréamont', 'Aloysius Bertrand', 'Tristan Corbière', 'Jules Laforgue',
            // Anglais
            'John Donne', 'George Herbert', 'Thomas Traherne', 'Christopher Smart',
            // Allemand
            'Novalis', 'Hölderlin', 'Rilke', 'Trakl',
            // Italien
            'Leopardi', 'Ungaretti', 'Montale',
            // Espagnol
            'Góngora', 'Quevedo', 'San Juan de la Cruz',
            // Russe
            'Tyutchev', 'Mandelstam', 'Akhmatova',
            // Latin
            'Catullus', 'Propertius', 'Tibullus'
        ];
        
        // Messages fun aléatoires
        const FUN_MESSAGES = [
            "🦇 Vous vous enfoncez dans les ténèbres littéraires...",
            "🌀 La spirale des mots vous aspire...",
            "📚 Les livres murmurent votre nom...",
            "🕯️ Une bougie vacille dans la bibliothèque...",
            "🗝️ Vous avez trouvé une porte secrète...",
            "🦉 Un hibou vous observe depuis les étagères...",
            "🌙 La lune éclaire un passage inconnu...",
            "🎭 Les personnages vous guettent...",
            "⚗️ L'encre des siècles vous enivre...",
            "🏚️ Vous errez dans le grenier des âmes...",
            "🌊 Les vers déferlent comme des vagues...",
            "🔮 Le cristal révèle un auteur oublié...",
            "🕸️ La toile littéraire se tisse autour de vous...",
            "☄️ Un météore de mots traverse votre esprit...",
            "🎪 Bienvenue dans le cirque des poètes maudits..."
        ];
        
        // Badges/Achievements
        const ACHIEVEMENTS = {
            first_read: { icon: '📖', name: 'Premier pas', desc: 'Lire votre premier texte' },
            explorer_5: { icon: '🗺️', name: 'Explorateur', desc: 'Découvrir 5 auteurs' },
            explorer_15: { icon: '🧭', name: 'Aventurier', desc: 'Découvrir 15 auteurs' },
            explorer_30: { icon: '🏴‍☠️', name: 'Corsaire littéraire', desc: 'Découvrir 30 auteurs' },
            night_owl: { icon: '🦉', name: 'Noctambule', desc: 'Lire après minuit' },
            century_jump: { icon: '⏳', name: 'Voyageur temporel', desc: 'Passer du XIXe au XVIe siècle' },
            hidden_gem: { icon: '💎', name: 'Dénicheur', desc: 'Trouver un auteur secret' },
            love_10: { icon: '❤️‍🔥', name: 'Passionné', desc: 'Aimer 10 textes' },
            marathon: { icon: '🏃', name: 'Marathonien', desc: 'Lire 25 textes d\'affilée' },
            mystique: { icon: '✨', name: 'Mystique', desc: 'Explorer 5 textes mystiques' },
            poete_maudit: { icon: '🖤', name: 'Poète maudit', desc: 'Découvrir Lautréamont' },
            renaissance: { icon: '🏛️', name: 'Renaissance', desc: 'Lire 3 auteurs du XVIe' },
            symbolist: { icon: '🦢', name: 'Symboliste', desc: 'Explorer Mallarmé et Verlaine' }
        };
        
        // Saut aléatoire SANS thématique (ignore l'ambiance)
        async function pureRandomJump() {
            const discoveredAuthors = Object.keys(state.authorStats);
            const universalTerms = ['sonnet', 'elegy', 'ode', 'ballade', 'fable', 'hymn', 'nocturne', 'poème', 'conte', 'roman'];
            const allOptions = [...discoveredAuthors, ...HIDDEN_GEMS, ...universalTerms, ...DEFAULT_AUTHORS];
            const unvisited = allOptions.filter(a => !state.authorStats[a]);
            const pool = unvisited.length > 3 ? unvisited : allOptions;
            
            const chosen = pool[Math.floor(Math.random() * pool.length)];
            
            toast('🎲 Découverte libre...');
            
            setTimeout(async () => {
                await exploreAuthor(chosen);
                checkAchievements();
                updateFunStat();
            }, 800);
        }
        
        // Saut aléatoire vers un auteur ou terme de recherche aléatoire
        async function randomJump() {
            const ambiance = AMBIANCES[currentAmbiance];
            let pool = [];
            
            // Si une ambiance spécifique est active, utiliser ses auteurs/mots-clés
            if (currentAmbiance !== 'libre' && ambiance.authors.length > 0) {
                pool = [...ambiance.authors, ...ambiance.keywords];
            } else {
                // Mode libre : comportement classique
                const discoveredAuthors = Object.keys(state.authorStats);
                const universalTerms = ['sonnet', 'elegy', 'ode', 'ballade', 'fable', 'hymn', 'nocturne'];
                const allOptions = [...discoveredAuthors, ...HIDDEN_GEMS, ...universalTerms];
                const unvisited = allOptions.filter(a => !state.authorStats[a] && !HIDDEN_GEMS.includes(a) || HIDDEN_GEMS.includes(a));
                pool = unvisited.length > 3 ? unvisited : allOptions;
            }
            
            const chosen = pool[Math.floor(Math.random() * pool.length)];
            
            toast(FUN_MESSAGES[Math.floor(Math.random() * FUN_MESSAGES.length)]);
            
            setTimeout(async () => {
                await exploreAuthor(chosen);
                checkAchievements();
                updateFunStat();
            }, 1500);
        }
        
        // Mise à jour du message fun
        function updateFunStat() {
            const el = document.getElementById('funStat');
            if (!el) return;
            
            const authorCount = Object.keys(state.authorStats).length;
            const readCount = state.readCount || 0;
            const likeCount = state.likes?.size || 0;
            
            const funStats = [
                `🌡️ Température littéraire : ${Math.min(100, readCount * 3)}°`,
                `🧬 ${authorCount} ADN d'auteurs dans votre sang`,
                `💫 ${likeCount} étincelles dans votre bibliothèque intérieure`,
                `🌀 Profondeur de dérive : niveau ${Math.floor(readCount / 5)}`,
                `🔥 Combo actuel : ${readCount} textes sans pause`,
                `🎲 Prochain saut aléatoire dans ${Math.max(1, 5 - (readCount % 5))} textes`,
                `📡 Signal littéraire : ${Math.min(100, authorCount * 5)}% de couverture`,
                `🧪 Dose de poésie : ${Math.floor(readCount * 2.7)}mg`,
            ];
            
            el.textContent = funStats[Math.floor(Math.random() * funStats.length)];
            el.style.opacity = '0';
            setTimeout(() => el.style.opacity = '1', 100);
        }
        
        // Vérification et déblocage des achievements
        function checkAchievements() {
            const authorCount = Object.keys(state.authorStats).length;
            const readCount = state.readCount || 0;
            const likeCount = state.likes?.size || 0;
            const hour = new Date().getHours();
            
            const checks = [
                ['first_read', readCount >= 1],
                ['explorer_5', authorCount >= 5],
                ['explorer_15', authorCount >= 15],
                ['explorer_30', authorCount >= 30],
                ['night_owl', hour >= 0 && hour < 5],
                ['love_10', likeCount >= 10],
                ['marathon', readCount >= 25],
                ['mystique', (state.genreStats?.mystique || 0) >= 5],
                ['hidden_gem', HIDDEN_GEMS.some(a => state.authorStats[a])],
                ['poete_maudit', !!state.authorStats['Comte de Lautréamont']],
                ['symbolist', state.authorStats['Stéphane Mallarmé'] && state.authorStats['Paul Verlaine']]
            ];
            
            for (const [id, condition] of checks) {
                if (condition && !state.achievements.includes(id)) {
                    unlockAchievement(id);
                }
            }
        }
        
        // Animation de déblocage d'achievement
        function unlockAchievement(id) {
            const ach = ACHIEVEMENTS[id];
            if (!ach) return;
            
            state.achievements.push(id);
            saveState();
            
            // Notification spéciale
            const notif = document.createElement('div');
            notif.className = 'achievement-popup';
            notif.innerHTML = `
                <div class="achievement-icon">${ach.icon}</div>
                <div class="achievement-info">
                    <div class="achievement-title">🏆 Badge débloqué !</div>
                    <div class="achievement-name">${ach.name}</div>
                    <div class="achievement-desc">${ach.desc}</div>
                </div>
            `;
            document.body.appendChild(notif);
            
            setTimeout(() => notif.classList.add('show'), 100);
            setTimeout(() => {
                notif.classList.remove('show');
                setTimeout(() => notif.remove(), 500);
            }, 4000);
            
            renderAchievements();
        }
        
        // Affichage des badges avec progression
        function renderAchievements() {
            const container = document.getElementById('achievementList');
            if (!container) return;
            
            const authorCount = Object.keys(state.authorStats).length;
            const readCount = state.readCount || 0;
            const likeCount = state.likes?.size || 0;
            const mystiqueCount = state.genreStats?.mystique || 0;
            
            // Définir la progression pour chaque badge
            const badgeProgress = {
                first_read: { current: Math.min(readCount, 1), target: 1, text: readCount >= 1 ? 'Complété !' : `${readCount}/1 texte lu` },
                explorer_5: { current: Math.min(authorCount, 5), target: 5, text: authorCount >= 5 ? 'Complété !' : `${authorCount}/5 auteurs découverts` },
                explorer_15: { current: Math.min(authorCount, 15), target: 15, text: authorCount >= 15 ? 'Complété !' : `${authorCount}/15 auteurs découverts` },
                explorer_30: { current: Math.min(authorCount, 30), target: 30, text: authorCount >= 30 ? 'Complété !' : `${authorCount}/30 auteurs découverts` },
                night_owl: { current: 0, target: 1, text: 'Lisez entre minuit et 5h du matin', special: true },
                century_jump: { current: 0, target: 1, text: 'Passez du XIXe au XVIe siècle', special: true },
                hidden_gem: { 
                    current: HIDDEN_GEMS.some(a => state.authorStats[a]) ? 1 : 0, 
                    target: 1, 
                    text: HIDDEN_GEMS.some(a => state.authorStats[a]) ? 'Complété !' : 'Trouvez un auteur secret caché' 
                },
                love_10: { current: Math.min(likeCount, 10), target: 10, text: likeCount >= 10 ? 'Complété !' : `${likeCount}/10 textes aimés` },
                marathon: { current: Math.min(readCount, 25), target: 25, text: readCount >= 25 ? 'Complété !' : `${readCount}/25 textes lus d'affilée` },
                mystique: { current: Math.min(mystiqueCount, 5), target: 5, text: mystiqueCount >= 5 ? 'Complété !' : `${mystiqueCount}/5 textes mystiques explorés` },
                poete_maudit: { 
                    current: state.authorStats['Comte de Lautréamont'] ? 1 : 0, 
                    target: 1, 
                    text: state.authorStats['Comte de Lautréamont'] ? 'Complété !' : 'Découvrez Lautréamont' 
                },
                renaissance: { 
                    current: 0, target: 3, 
                    text: 'Lisez 3 auteurs du XVIe siècle', special: true 
                },
                symbolist: { 
                    current: (state.authorStats['Stéphane Mallarmé'] ? 1 : 0) + (state.authorStats['Paul Verlaine'] ? 1 : 0), 
                    target: 2, 
                    text: `Découvrez Mallarmé ${state.authorStats['Stéphane Mallarmé'] ? '✓' : '○'} et Verlaine ${state.authorStats['Paul Verlaine'] ? '✓' : '○'}` 
                }
            };
            
            const unlockedCount = state.achievements.length;
            const totalBadges = Object.keys(ACHIEVEMENTS).length;
            
            // Mettre à jour le compteur
            document.getElementById('unlockedCount').textContent = unlockedCount;
            document.getElementById('totalBadges').textContent = totalBadges;
            
            container.innerHTML = Object.entries(ACHIEVEMENTS).map(([id, ach]) => {
                const unlocked = state.achievements.includes(id);
                const progress = badgeProgress[id] || { current: 0, target: 1, text: ach.desc };
                const percent = Math.min(100, Math.round((progress.current / progress.target) * 100));
                
                return `
                    <div class="achievement ${unlocked ? 'unlocked' : 'locked'}" onclick="showBadgeDetails('${id}')">
                        <div class="badge-icon">${ach.icon}</div>
                        <div class="badge-info">
                            <div class="badge-name">
                                ${ach.name}
                                ${unlocked ? '<span class="unlocked-check">✓</span>' : ''}
                            </div>
                            <div class="badge-desc">${ach.desc}</div>
                            ${!unlocked && !progress.special ? `
                                <div class="badge-progress">
                                    <div class="badge-progress-bar">
                                        <div class="badge-progress-fill" style="width: ${percent}%"></div>
                                    </div>
                                    <div class="badge-progress-text">${progress.text}</div>
                                </div>
                            ` : !unlocked && progress.special ? `
                                <div class="badge-progress">
                                    <div class="badge-progress-text">💡 ${progress.text}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Toggle entre afficher tous les badges ou seulement les débloqués
        let badgesExpanded = true;
        function toggleBadgesView() {
            badgesExpanded = !badgesExpanded;
            const container = document.getElementById('achievementList');
            const toggle = document.getElementById('badgesToggle');
            
            if (badgesExpanded) {
                container.classList.remove('collapsed');
                toggle.textContent = 'Voir tout';
            } else {
                container.classList.add('collapsed');
                toggle.textContent = 'Débloqués seulement';
            }
        }
        
        // Afficher les détails d'un badge
        function showBadgeDetails(id) {
            const ach = ACHIEVEMENTS[id];
            if (!ach) return;
            
            const unlocked = state.achievements.includes(id);
            
            const hints = {
                first_read: "Cliquez sur n'importe quel texte pour commencer votre voyage littéraire !",
                explorer_5: "Explorez différents auteurs en utilisant le bouton 🎲 ou la recherche.",
                explorer_15: "Continuez à découvrir de nouveaux auteurs. Chaque nom cache un univers !",
                explorer_30: "Devenez un véritable corsaire des lettres en naviguant entre 30 auteurs différents.",
                night_owl: "Les plus beaux textes se lisent parfois à la lueur de la lune... Revenez entre minuit et 5h !",
                century_jump: "Voyagez dans le temps ! Lisez un auteur du XIXe puis sautez au XVIe siècle.",
                hidden_gem: "Certains auteurs sont cachés... Cherchez les trésors oubliés de la littérature.",
                love_10: "Cliquez sur ♥ pour sauvegarder vos textes préférés. 10 coups de cœur = 1 badge !",
                marathon: "Lisez 25 textes sans vous arrêter. Un vrai marathon littéraire !",
                mystique: "Explorez les textes aux thèmes mystiques, ésotériques ou spirituels.",
                poete_maudit: "Recherchez 'Lautréamont' ou 'Maldoror' pour découvrir ce poète maudit légendaire.",
                renaissance: "Recherchez des auteurs du XVIe siècle : Ronsard, Du Bellay, Rabelais...",
                symbolist: "Les symbolistes Mallarmé et Verlaine vous attendent. Recherchez leurs noms !"
            };
            
            toast(`${ach.icon} ${ach.name}${unlocked ? ' (Débloqué !)' : ''} - ${hints[id] || ach.desc}`, 5000);
        }
        
        // Chemin de lecture (breadcrumb visuel)
        function addToReadingPath(author, title) {
            if (!state.readingPath) state.readingPath = [];
            
            // Garder les 8 derniers
            state.readingPath.push({ author, title: title?.split('/')[0] || '?', time: Date.now() });
            if (state.readingPath.length > 8) state.readingPath.shift();
            
            renderReadingPath();
            saveState();
        }
        
        function renderReadingPath() {
            const container = document.getElementById('readingPath');
            if (!container || !state.readingPath?.length) return;
            
            container.innerHTML = state.readingPath.map((node, i) => `
                <span class="path-node" title="${node.title}">
                    ${node.author.split(' ').pop()}
                </span>
                ${i < state.readingPath.length - 1 ? '<span class="path-arrow">→</span>' : ''}
            `).join('');
        }

        document.onkeydown = e => { if (e.key === 'Escape') closeReader(); };
        
        init();
    </script>
</body>
</html>